<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>6. Symmetric-Key Cryptography - Computer Security</title> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Symmetric-Key Cryptography | Computer Security</title> <meta name="generator" content="Jekyll v3.9.2" /> <meta property="og:title" content="Symmetric-Key Cryptography" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <meta property="og:description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <link rel="canonical" href="/crypto/symmetric.html" /> <meta property="og:url" content="/crypto/symmetric.html" /> <meta property="og:site_name" content="Computer Security" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Symmetric-Key Cryptography" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Online textbook for CS 161: Computer Security at UC Berkeley.","headline":"Symmetric-Key Cryptography","url":"/crypto/symmetric.html"}</script> <!-- End Jekyll SEO tag --> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" ></script> <script> let toggleDark = () => { let setDark = jtd.getTheme() !== 'dark'; jtd.setTheme(setDark ? 'dark' : 'default'); localStorage.setItem('darkMode', String(setDark)); }; window.addEventListener('DOMContentLoaded', () => { /* Add event to dark mode button. */ let a = document.getElementsByClassName('site-button')[2]; a.addEventListener('click', (e) => { e.preventDefault(); toggleDark(); }); /* Read local storage state. */ if (localStorage.getItem('darkMode') === 'true') { toggleDark(); } }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/" class="site-title lh-tight"> Computer Security </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Introduction</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Security Principles category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/principles/" class="nav-list-link">Security Principles</a><ul class="nav-list "><li class="nav-list-item "><a href="/principles/principles.html" class="nav-list-link">1. Security Principles</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Memory Safety category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/memory-safety/" class="nav-list-link">Memory Safety</a><ul class="nav-list "><li class="nav-list-item "><a href="/memory-safety/x86.html" class="nav-list-link">2. x86 Assembly and Call Stack</a></li><li class="nav-list-item "><a href="/memory-safety/vulnerabilities.html" class="nav-list-link">3. Memory Safety Vulnerabilities</a></li><li class="nav-list-item "><a href="/memory-safety/mitigations.html" class="nav-list-link">4. Mitigating Memory-Safety Vulnerabilities</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Cryptography category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/crypto/" class="nav-list-link">Cryptography</a><ul class="nav-list "><li class="nav-list-item "><a href="/crypto/intro.html" class="nav-list-link">5. Introduction to Cryptography</a></li><li class="nav-list-item active"><a href="/crypto/symmetric.html" class="nav-list-link active">6. Symmetric-Key Cryptography</a></li><li class="nav-list-item "><a href="/crypto/hashes.html" class="nav-list-link">7. Cryptographic Hashes</a></li><li class="nav-list-item "><a href="/crypto/macs.html" class="nav-list-link">8. Message Authentication Codes (MACs)</a></li><li class="nav-list-item "><a href="/crypto/prng.html" class="nav-list-link">9. Pseudorandom Number Generators</a></li><li class="nav-list-item "><a href="/crypto/key-exchange.html" class="nav-list-link">10. Diffie-Hellman Key Exchange</a></li><li class="nav-list-item "><a href="/crypto/public-key.html" class="nav-list-link">11. Public-Key Encryption</a></li><li class="nav-list-item "><a href="/crypto/signatures.html" class="nav-list-link">12. Digital Signatures</a></li><li class="nav-list-item "><a href="/crypto/certificates.html" class="nav-list-link">13. Certificates</a></li><li class="nav-list-item "><a href="/crypto/passwords.html" class="nav-list-link">14. Passwords</a></li><li class="nav-list-item "><a href="/crypto/case-studies.html" class="nav-list-link">15. Case Studies</a></li><li class="nav-list-item "><a href="/crypto/bitcoin.html" class="nav-list-link">16. Bitcoin</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Web Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/web/" class="nav-list-link">Web Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/web/sqli.html" class="nav-list-link">17. SQL Injection</a></li><li class="nav-list-item "><a href="/web/intro.html" class="nav-list-link">18. Introduction to the Web</a></li><li class="nav-list-item "><a href="/web/sop.html" class="nav-list-link">19. Same-Origin Policy</a></li><li class="nav-list-item "><a href="/web/cookies.html" class="nav-list-link">20. Cookies and Session Management</a></li><li class="nav-list-item "><a href="/web/csrf.html" class="nav-list-link">21. Cross-Site Request Forgery (CSRF)</a></li><li class="nav-list-item "><a href="/web/xss.html" class="nav-list-link">22. Cross-Site Scripting (XSS)</a></li><li class="nav-list-item "><a href="/web/ui-attacks.html" class="nav-list-link">23. UI Attacks</a></li><li class="nav-list-item "><a href="/web/captchas.html" class="nav-list-link">24. CAPTCHAs</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Network Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/network/" class="nav-list-link">Network Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/network/intro.html" class="nav-list-link">25. Introduction to Networking</a></li><li class="nav-list-item "><a href="/network/arp.html" class="nav-list-link">26. ARP</a></li><li class="nav-list-item "><a href="/network/wpa.html" class="nav-list-link">27. WPA</a></li><li class="nav-list-item "><a href="/network/dhcp.html" class="nav-list-link">28. DHCP</a></li><li class="nav-list-item "><a href="/network/bgp.html" class="nav-list-link">29. BGP</a></li><li class="nav-list-item "><a href="/network/transport.html" class="nav-list-link">30. TCP and UDP</a></li><li class="nav-list-item "><a href="/network/tls.html" class="nav-list-link">31. TLS</a></li><li class="nav-list-item "><a href="/network/dns.html" class="nav-list-link">32. DNS</a></li><li class="nav-list-item "><a href="/network/dnssec.html" class="nav-list-link">33. DNSSEC</a></li><li class="nav-list-item "><a href="/network/dos.html" class="nav-list-link">34. Denial-of-Service (DoS)</a></li><li class="nav-list-item "><a href="/network/firewalls.html" class="nav-list-link">35. Firewalls</a></li><li class="nav-list-item "><a href="/network/intrusion-detection.html" class="nav-list-link">36. Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/abusing-intrusion-detection.html" class="nav-list-link">37. Abusing Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/malware.html" class="nav-list-link">38. Malware</a></li><li class="nav-list-item "><a href="/network/tor.html" class="nav-list-link">39. Anonymity and Tor</a></li></ul></li><li class="nav-list-item"><a href="/glossary.html" class="nav-list-link">Glossary</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Computer Security" aria-label="Search Computer Security" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://cs161.org" class="site-button" > CS 161 </a> </li> <li class="aux-nav-list-item"> <a href="#" class="site-button" > Dark Mode </a> </li> </ul> </nav> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/crypto/">Cryptography</a></li> <li class="breadcrumb-nav-list-item"><span>6. Symmetric-Key Cryptography</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 id="6-symmetric-key-encryption"> <a href="#6-symmetric-key-encryption" class="anchor-heading" aria-labelledby="6-symmetric-key-encryption"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6. Symmetric-Key Encryption </h1> <p>In this section, we will build symmetric-key encryption schemes that guarantee confidentiality. Because we are in the symmetric key setting, in this section we can assume that Alice and Bob share a secret key that is not known to anyone else. Later we will see how Alice and Bob might securely exchange a shared secret key over an insecure communication channel, but for now you can assume that only Alice and Bob know the value of the secret key.</p> <p>For modern schemes, we are going to assume that all messages are bitstrings, which is a sequence of bits, 0 or 1 (e.g. <code class="language-plaintext highlighter-rouge">1101100101010101</code>). Text, images, and most other forms of communication can usually be converted into bitstrings before encryption, so this is a useful abstraction.</p> <h2 id="61-ind-cpa-security"> <a href="#61-ind-cpa-security" class="anchor-heading" aria-labelledby="61-ind-cpa-security"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.1. IND-CPA Security </h2> <p>Recall from the previous chapter that confidentiality was defined to mean that an attacker cannot read our messages. This definition, while intuitive, is quite open-ended. If the attacker can read the first half of our message but not the second half, is that confidential? What if the attacker can deduce that our message starts with the words “Dear Bob?” It might also be the case that the attacker had some partial information about the message \(M\) to begin with. Perhaps she knew that the last bit of \(M\) is a \(0\), or that \(90\%\) of the bits of \(M\) are \(1\)’s, or that \(M\) is one of BUY! or SELL but does not know which.</p> <p>A more formal, rigorous definition of confidentiality is: the ciphertext \(C\) should give the attacker no additional information about the message \(M\). In other words, the attacker should not learn any new information about \(M\) beyond what they already knew before seeing \(C\) (seeing \(C\) should not give the attacker any new information).</p> <p>We can further formalize this definition by designing an experiment to test whether the attacker has learned any additional information. Consider the following experiment: Alice has encrypted and sent one of two messages, either \(M_0\) or \(M_1\), and the attacker, Eve, has no idea which was sent. Eve tries to guess which was sent by looking at the ciphertext. If the encryption scheme is confidential, then Eve’s probability of guessing which message was sent should be \(1/2\), which is the same probability as if she had not intercepted the ciphertext at all, and was instead guessing at random.</p> <p>We can adapt this experiment to different threat models by allowing Eve to perform further actions as an attacker. For example, Eve might be allowed to trick Alice into encrypting some messages of Eve’s choosing. Eve might also be allowed to trick Alice into decrypting some ciphertexts of Eve’s choosing. In this class, we will be focusing on the chosen-plaintext attack model, which means Eve can trick Alice into encrypting some messages, but she cannot trick Alice into decrypting some messages.</p> <p>In summary, our definition of confidentiality says that even if Eve can trick Alice into encrypting some messages, she still cannot distinguish whether Alice sent \(M_0\) or \(M_1\) in the experiment. This definition is known as indistinguishability under chosen plaintext attack, or IND-CPA. We can use an experiment or game, played between the adversary Eve and the challenger Alice, to formally prove that a given encryption scheme is IND-CPA secure or show that it is not IND-CPA secure.</p> <p>The IND-CPA game works as follows:</p> <ol> <li> <p>The adversary Eve chooses two different messages, \(M_0\) and \(M_1\), and sends both messages to Alice.</p> </li> <li> <p>Alice flips a fair coin. If the coin is heads, she encrypts \(M_0\). If the coin is tails, she encrypts \(M_1\). Formally, Alice chooses a bit \(b \in \{0, 1\}\) uniformly at random, and then encrypts \(M_b\). Alice sends the encrypted message \(Enc(K, M_b)\) back to Eve.</p> </li> <li> <p>Eve is now allowed to ask Alice for encryptions of messages of Eve’s choosing. Eve can send a plaintext message to Alice, and Alice will always send back the encryption of the message with the secret key. Eve is allowed to repeat this as many times as she wants. Intuitively, this step is allowing Eve to perform a chosen-plaintext attack in an attempt to learn something about which message was sent.</p> </li> <li> <p>After Eve is finished asking for encryptions, she must guess whether the encrypted message from step 2 is the encryption of \(M_0\) or \(M_1\).</p> </li> </ol> <p>If Eve can guess which message was sent with probability \(&gt; 1/2\), then Eve has won the game. This means that Eve has learned some information about which message was sent, so the scheme is not IND-CPA secure. On the other hand, if Eve cannot do any better than guess with \(1/2\) probability, then Alice has won the game. Eve has learned nothing about which message was sent, so the scheme is IND-CPA secure.</p> <p>There are a few important caveats to the IND-CPA game to make it a useful, practical security definition:</p> <p><em>The messages \(M_0\) and \(M_1\) must be the same length.</em> In almost all practical cryptosystems, we allow ciphertexts to leak the length of the plaintext. Why? If we want a scheme that doesn’t reveal the length of the plaintext, then we would need every ciphertext to be the same length. If the ciphertext is always \(n\) bits long, then we wouldn’t be able to encrypt any messages longer than \(n\) bits, which makes for a very impractical system. You could make \(n\) very large so that you can encrypt most messages, but this would mean encrypting a one-bit message requires an enormous \(n\)-bit ciphertext. Either way, such a system would be very impractical in real life, so we allow cryptosystems to leak the length of the plaintext.</p> <p>If we didn’t force \(M_0\) and \(M_1\) to be the same length, then our game would incorrectly mark some IND-CPA secure schemes as insecure. In particular, if a scheme leaks the plaintext length, it can still be considered IND-CPA secure. However, Eve would win the IND-CPA game with this scheme, since she can send a short message and a long message, see if Alice sends back a short or long ciphertext, and distinguish which message was sent. To account for the fact that cryptosystems can leak plaintext length, we use equal-length messages in the IND-CPA game.</p> <p><em>Eve is limited to a practical number of encryption requests.</em> In practice, some schemes may be vulnerable to attacks but considered secure anyway, because those attacks are computationally infeasible. For example, Eve could try to brute-force a 128-bit secret key, but this would take \(2^{128}\) computations. If each computation took 1 millisecond, this would take \(10^{28}\) years, far longer than the age of our solar system. These attacks may be theoretically possible, but they are so inefficient that we don’t need to worry about attackers who try them. To account for these computationally infeasible attacks in the IND-CPA game, we limit Eve to a practical number of encryption requests. One commonly-used measure of practicality is polynomially-bounded runtime: any algorithm Eve uses during the game must run in \(O(n^k)\) time, for some constant \(k\).</p> <p><em>Eve only wins if she has a non-negligible advantage.</em> Consider a scheme where Eve can correctly which message was sent with probability \(1/2 + 1/2^{128}\). This number is greater than \(1/2\), but Eve’s advantage is \(1/2^{128}\), which is astronomically small. In this case, we say that Eve has <em>negligible</em> advantage–the advantage is so small that Eve cannot use it to mount any practical attacks. For example, the scheme might use a 128-bit key, and Eve can break the scheme if she guesses the key (with probability \(1/2^{128}\)). Although this is theoretically a valid attack, the odds of guessing a 128-bit key are so astronomically small that we don’t need to worry about it. The exact definition of negligible is beyond the scope of this class, but in short, Eve only wins the IND-CPA game if she can guess which message was sent with probability greater than \(1/2 + n\), where \(n\) is some non-negligible probability.</p> <p>You might have noticed that in step 3, there is nothing preventing Eve from asking Alice for the encryption of \(M_0\) or \(M_1\) again. This is by design: it means any deterministic scheme is not IND-CPA secure, and it forces any IND-CPA secure scheme to be non-deterministic. Informally, a deterministic scheme is one that, given a particular input, will always produce the same output. For example, the Caesar Cipher that was seen in the previous chapter is a deterministic scheme since giving it the same input twice will always produce the same output (i.e. inputting “abcd” will always output “cdef” when we shift by 2). As we’ll see later, deterministic schemes do leak information, so this game will correctly classify them as IND-CPA insecure. In a later section we’ll also see how to win the IND-CPA game against a deterministic scheme.</p> <h2 id="62-xor-review"> <a href="#62-xor-review" class="anchor-heading" aria-labelledby="62-xor-review"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.2. XOR review </h2> <p>Symmetric-key encryption often relies on the bitwise XOR (exclusive-or) operation (written as \(\oplus\)), so let’s review the definition of XOR.</p> \[\begin{aligned} 0 \oplus 0 &amp;= 0 \\ 0 \oplus 1 &amp;= 1 \\ 1 \oplus 0 &amp;= 1 \\ 1 \oplus 1 &amp;= 0 \end{aligned}\] <p>Given this definition, we can derive some useful properties:</p> \[\begin{aligned} x \oplus 0 &amp;= x &amp; &amp;\text{0 is the identity} \\ x \oplus x &amp;= 0 &amp; &amp;\text{$x$ is its own inverse} \\ x \oplus y &amp;= y \oplus x &amp; &amp;\text{commutative property} \\ (x \oplus y) \oplus z &amp;= x \oplus (y \oplus z) &amp; &amp;\text{associative property} \end{aligned}\] <p>One handy identity that follows from these is: \(x \oplus y \oplus x = y\). In other words, given \((x \oplus y)\), you can retrieve \(y\) by computing \((x \oplus y) \oplus x\), effectively “cancelling out” the \(x\).</p> <p>We can also perform algebra with the XOR operation:</p> \[\begin{aligned} y \oplus 1 &amp;= 0 &amp; &amp;\text{goal: solve for y} \\ y \oplus 1 \oplus 1 &amp;= 0 \oplus 1 &amp; &amp;\text{XOR both sides by 1} \\ y &amp;= 1 &amp; &amp;\text{simplify left-hand side using the identity above} \end{aligned}\] <h2 id="63-one-time-pad"> <a href="#63-one-time-pad" class="anchor-heading" aria-labelledby="63-one-time-pad"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.3. One Time Pad </h2> <p>The first symmetric encryption scheme we’ll look at is the <em>one-time pad (OTP)</em>. The one time pad is a simple and idealized encryption scheme that helps illustrate some important concepts, though as we will see shortly, it is impractical for real-world use.</p> <p>In the one-time pad scheme, Alice and Bob share an \(n\)-bit secret key \(K = k_1 \cdots k_n\) where the bits \(k_1, \ldots k_n\) are picked uniformly at random (they are the outcomes of independent unbiased coin flips, meaning that to pick \(k_1\) a coin is flipped and if it lands on heads, then \(k_1\) is assigned 1, but if it lands on tails, \(k_1\) is assigned 0).</p> <p>Suppose Alice wishes to send the n-bit message \(M = m_1 \cdots m_n\).</p> <p>The desired properties of the encryption scheme are:</p> <ol> <li> <p>It should scramble up the message, i.e., map it to a ciphertext \(C = c_1 \cdots c_n\).</p> </li> <li> <p>Given knowledge of the secret key \(K\), it should be easy to recover \(M\) from \(C\).</p> </li> <li> <p>Eve, who does not know \(K\), should get <em>no</em> information about \(M\).</p> </li> </ol> <p>Encryption in the one-time pad is very simple: \(c_j = m_j \oplus k_j\). In words, you perform a bitwise XOR of the message and the key. The \(j\)th bit of the ciphertext is the \(j\)th bit of the message, XOR with the \(j\)th bit of the key.</p> <p>We can derive the decryption algorithm by doing some algebra on the encryption equation:</p> \[\begin{aligned} c_j &amp;= m_j \oplus k_j &amp; &amp;\text{encryption equation, solve for } m_j \\ c_j \oplus k_j &amp;= m_j \oplus k_j \oplus k_j &amp; &amp;\text{XOR both sides by } k_j \\ c_j \oplus k_j &amp;= m_j &amp; &amp;\text{simplify right-hand side using the handy identity from above} \end{aligned}\] <p>In words, given ciphertext \(C\) and key \(K\), the \(j\)th bit of the plaintext is the \(j\)th bit of the ciphertext, XOR with the \(j\)th bit of the key.</p> <p>To sum up, the one-time pad is described by specifying three procedures:</p> <ul> <li> <p>Key generation: Alice and Bob pick a shared random key \(K\).</p> </li> <li> <p>Encryption algorithm: \(C = M \oplus K\).</p> </li> <li> <p>Decryption algorithm: \(M = C \oplus K\).</p> </li> </ul> <p>Now let’s prove that the one-time pad is IND-CPA secure. In other words, we want to show that in the IND-CPA game, the adversary Eve’s probability of guessing which message was sent is \(1/2\).</p> <p>Proof: For a fixed choice of plaintext \(M\), every possible value of the ciphertext \(C\) can be achieved by an appropriate and unique choice of the shared key \(K\): namely \(K = M \oplus C\). Since each such key value \(K\) is equally likely, it follows that \(C\) is also equally likely to be any \(n\)-bit string. Thus Eve sees a uniformly random \(n\) bit string no matter what the plaintext message was, and thus gets no information about which of the two messages was encrypted.</p> <p>Here’s another way to see that Eve’s probability of guessing successfully is \(1/2\). Suppose Eve observes the ciphertext \(C\), and she knows that the message \(M\) is either \(M_0\) or \(M_1\), but she does not know which. The probability space here has size \(2^{n+1}\): it represents the \(2^n\) choices for the \(n\)-bit key \(K\), as well as the challenger’s choice of whether to send \(M_0\) or \(M_1\). All \(2^{n+1}\) choices are equally likely. We can assume the key \(K\) is generated uniformly at random; then the challenger randomly chooses a bit \(b \in \{0,1\}\), and Alice sends the encryption of \(M_b\). So, if Eve observes that the ciphertext has some specific value \(C\), what is the conditional probability that \(b=0\) given her observation? It is:</p> \[\begin{aligned} \Pr[b = 0 \mid \textrm{ciphertext} = C] &amp;= \frac{\Pr[b = 0 \wedge \textrm{ciphertext} = C]}{\Pr[\textrm{ciphertext} = C]} \\ &amp;= \frac{\Pr[b = 0 \wedge K = M_0 \oplus C]}{\Pr[\textrm{ciphertext} = C]} \\ &amp;= \frac{1/2 \cdot 1/2^n}{1/2^n} \\ &amp;= \frac{1}{2}. \end{aligned}\] <p>The one time pad has a major drawback. As its name suggests, the shared key cannot be reused to transmit another message \(M'\). If the key \(K\) is reused to encrypt two messages \(M\) and \(M'\), then Eve can take the XOR of the two ciphertexts \(C = M \oplus K\) and \(C' = M' \oplus K\) to obtain \(C \oplus C' = M \oplus M'\). This gives partial information about the two messages. In particular, if Eve happens to learn \(M\), then she can deduce the other message \(M'\). In other words, given \(M \oplus M'\) and \(M\), she can calculate \(M' = (M \oplus M') \oplus M\). Actually, in this case, she can reconstruct the key \(K\), too. Question: How?<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p> <p>In practice, even if Eve does not know \(M\) or \(M'\), often there is enough redundancy in messages that merely knowing \(M \oplus M'\) is enough to recover most of \(M\) and \(M'\). For instance, the US exploited this weakness to read some World War II era Soviet communications encrypted with the one-time pad, when US cryptanalysts discovered that Soviet officials in charge of generating random keys for the one-time pad got lazy and started re-using old keys. The VENONA project, although initiated just shortly after World War II, remained secret until the early 1980s.</p> <p>We can see that the one-time pad with key reuse is insecure because Eve has learned something about the original messages (namely, the XOR of the two original messages). We can also formally prove that the one-time pad with key reuse is not IND-CPA secure by showing a strategy for the adversary Eve to correctly guess which message was encrypted, with probability greater than \(1/2\).</p> <p>Eve sends two messages, \(M_0\) and \(M_1\) to the challenger. The challenger randomly chooses one message to encrypt and sends it back to Eve. At this point, Eve knows she has received either \(M_0 \oplus K\) or \(M_1 \oplus K\), depending on which message was encrypted. Eve is now allowed to ask for the encryption of arbitrary messages, so she queries the challenger for the encryption of \(M_0\). The challenger is using the same key for every message, so Eve will receive \(M_0 \oplus K\). Eve can now compare this value to the encryption she is trying to guess: if the value matches, then Eve knows that the challenger encrypted \(M_0\) and sent \(M_0 \oplus K\). If the value doesn’t match, then Eve knows that the challenger encrypted \(M_1\) and sent \(M_1 \oplus K\). Thus Eve can guess which message the challenger encrypted with 100% probability! This is greater than \(1/2\) probability, so Eve has won the IND-CPA game, and we have proven that the one-time pad scheme with key reuse is insecure.</p> <p>Consequently, the one-time pad is not secure if the key is used to encrypt more than one message. This makes it impractical for almost all real-world situations–if Alice and Bob want to encrypt an \(n\)-bit message with a one-time pad, they will first need to securely send each other a new, previously unused \(n\)-bit key. But if they’ve found a method to securely exchange an \(n\)-bit key, they could have just used that same method to exchange the \(n\)-bit message!<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p> <h2 id="64-block-ciphers"> <a href="#64-block-ciphers" class="anchor-heading" aria-labelledby="64-block-ciphers"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.4. Block Ciphers </h2> <p>As we’ve just seen, generating new keys for every encryption is difficult and expensive. Instead, in most symmetric encryption schemes, Alice and Bob share a secret key and use this single key to repeatedly encrypt and decrypt messages. The block cipher is a fundamental building block in implementing such a symmetric encryption scheme.</p> <p>Intuitively, a block cipher transforms a fixed-length, \(n\)-bit input into a fixed-length \(n\)-bit output. The block cipher has \(2^k\) different settings for scrambling, so it also takes in a \(k\)-bit key as input to determine which scrambling setting should be used. Each key corresponds to a different scrambling setting. The idea is that an attacker who doesn’t know the secret key won’t know what mode of scrambling is being used, and thus won’t be able to decrypt messages encrypted with the block cipher.</p> <p>A block cipher has two operations: encryption takes in an \(n\)-bit plaintext and a \(k\)-bit key as input and outputs an \(n\)-bit ciphertext. Decryption takes in an \(n\)-bit ciphertext and a \(k\)-bit key as input and outputs an \(n\)-bit plaintext. Question: why does the decryption require the key as input?<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p> <p>Given a fixed scrambling setting (key), the block cipher encryption must map each of the \(2^n\) possible plaintext inputs to a different ciphertext output. In other words, given a specific key, the block cipher encryption must be able to map every possible input to a unique output. If the block cipher mapped two plaintext inputs to the same ciphertext output, there would be no way to decrypt that ciphertext back into plaintext, since that ciphertext could correspond to multiple different plaintexts. This means that the block cipher must also be <em>deterministic</em>. Given the same input and key, the block cipher should always give the same output.</p> <p>In mathematical notation, the block cipher can be described as follows. There is an encryption function \(E: \{0,1\}^k \times \{0,1\}^n \rightarrow \{0,1\}^n\). This notation means we are mapping a \(k\)-bit input (the key) and an \(n\)-bit input (the plaintext message) to an \(n\)-bit output (the ciphertext). Once we fix the key \(K\), we get a function mapping \(n\) bits to \(n\) bits: \(E_K:\{0,1\}^n \rightarrow \{0,1\}^n\) defined by \(E_K(M) = E(K, M)\). \(E_K\) is required to be a <em>permutation</em> on the \(n\)-bit strings, in other words, it must be an invertible (bijective) function. The inverse mapping of this permutation is the decryption algorithm \(D_K\). In other words, decryption is the reverse of encryption: \(D_K(E_K(M)) = M\).</p> <p>The block cipher as defined above is a category of functions, meaning that there are many different implementations of a block cipher. Today, the most commonly used block cipher implementation is called Advanced Encryption Standard (AES). It was designed in 1998 by Joan Daemen and Vincent Rijmen, two researchers from Belgium, in response to a competition organized by NIST.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p> <p>AES uses a block length of \(n=128\) bits and a key length of \(k=128\) bits. It can also support \(k=192\) or \(k=256\) bit keys, but we will assume 128-bit keys in this class. It was designed to be extremely fast in both hardware and software.</p> <h2 id="65-block-cipher-security"> <a href="#65-block-cipher-security" class="anchor-heading" aria-labelledby="65-block-cipher-security"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.5. Block Cipher Security </h2> <p>Block ciphers, including AES, are not IND-CPA secure on their own because they are deterministic. In other words, encrypting the same message twice with the same key produces the same output twice. The strategy that an adversary, Eve, uses to break the security of AES is exactly the same as the strategy from the one-time pad with key reuse. Eve sends \(M_0\) and \(M_1\) to the challenger and receives either \(E(K, M_0)\) or \(E(K, M_1)\). She then queries the challenger for the encryption of \(M_0\) and receives \(E(K, M_0)\). If the two encryptions she receives from the challenger are the same, then Eve knows the challenger encrypted \(M_0\) and sent \(E(K, M_0)\). If the two encryptions are different, then Eve knows the challenger encrypted \(M_1\) and sent \(E(K, M_1)\). Thus Eve can win the IND-CPA game with probability 100% \(&gt; 1/2\), and the block cipher is not IND-CPA secure.</p> <p>Although block ciphers are not IND-CPA secure, they have a desirable security property that will help us build IND-CPA secure symmetric encryption schemes: namely, a block cipher is <em>computationally indistinguishable</em> from a random permutation. In other words, for a fixed key \(K\), \(E_K\) “behaves like” a random permutation on the \(n\)-bit strings.</p> <p>A random permutation is a function that maps each \(n\)-bit input to exactly one random \(n\)-bit output. One way to generate a random permutation is to write out all \(2^n\) possible inputs in one column and all \(2^n\) possible outputs in another column, and then draw \(2^n\) random lines connecting each input to each output. Once generated, the function itself is not random: given the same input twice, the function gives the same output twice. However, the choice of which output is given is randomly determined when the function is created.</p> <p>Formally, we perform the following experiment to show that a block cipher is indistinguishable from a random permutation. The adversary, Eve, is given a box which contains either (I) the encryption function \(E_K\) with a randomly chosen key \(K\), or (II) a permutation \(\pi\) on \(n\) bits chosen uniformly at random when the box was created (in other words, map each \(n\)-bit input to a different random \(n\)-bit output). The type of box given to Eve is randomly selected, but we don’t tell Eve which type of box she has been given. We also don’t tell Eve the value of the key \(K\).</p> <p>Eve is now allowed to play with the box as follows: Eve can supply an input \(x\) to the box and receive a corresponding output \(y\) from the box (namely, \(y=E_K(x)\) for a type-I box, or \(y=\pi(x)\) for a type-II box). After playing with the box, Eve must guess whether the box is type I or type II. If the block cipher is truly indistinguishable from random, then Eve cannot guess which type of box she received with probability greater than \(1/2\).</p> <p>AES is not truly indistinguishable from random, but it is believed to be <em>computationally</em> indistinguishable from random. Intuitively, this means that given a practical amount of computation power (e.g. polynomially-bounded runtime), Eve cannot guess which type of box she received with probability greater than \(1/2\). Another way to think of computational indistinguishability is: Eve can guess which type of box she received with probability \(1/2\), plus some negligible amount (e.g. \(1/2^{128}\)). With infinite computational time and power, Eve could leverage this tiny \(1/2^{128}\) advantage to guess which box she received, but with only a practical amount of computation power, this advantage is useless for Eve.</p> <p>The computational indistinguishability property of AES gives us a strong security guarantee: given a single ciphertext \(C = E_K(M)\), an attacker without the key cannot learn anything about the original message \(M\). If the attacker could learn something about \(M\), then AES would no longer be computationally indistinguishable: in the experiment from before, Eve could feed \(M\) into the box and see if given only the output from the box, she can learn something about \(M\). If Eve learns something about \(M\), then she knows the output came from a block cipher. If Eve learns nothing about \(M\), then she knows the output came from a random permutation. However, since we believe that AES is computationally indistinguishable from random, we can say that an attacker who receives a ciphertext learns <em>nothing</em> about the original message.</p> <p>There is no proof that AES is computationally indistinguishable from random, but it is believed to be computationally indistinguishable. After all these years, the best known attack is still <em>exhaustive key search</em>, where the attacker systematically tries decrypting some ciphertext using every possible key to see which one gives intelligible plaintext. Given infinite computational time and power, exhaustive key search can break AES, which is why it is not truly indistinguishable from random. However, with a 128-bit key, exhaustive key search requires \(2^{128}\) computations in the worst case (\(2^{127}\) on average). This is a large enough number that even the fastest current supercomputers couldn’t possibly mount an exhaustive key search attack against AES within the lifetime of our Solar system.</p> <p>Thus AES behaves very differently than the one-time pad. Even given a very large number of plaintext/ciphertext pairs, there appears to be no effective way to decrypt any new ciphertexts. We can leverage this property to build symmetric-key encryption schemes where there is no effective way to decrypt <em>any</em> ciphertext, even if it’s the encryption of a message we’ve seen before.</p> <h2 id="66-block-cipher-modes-of-operation"> <a href="#66-block-cipher-modes-of-operation" class="anchor-heading" aria-labelledby="66-block-cipher-modes-of-operation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.6. Block Cipher Modes of Operation </h2> <p>There are two main reasons AES by itself cannot be a practical IND-CPA secure encryption scheme. The first is that we’d like to encrypt arbitrarily long messages, but the block cipher only takes fixed-length inputs. The other is that if the same message is sent twice, the ciphertext in the two transmissions is the same with AES (i.e. it is deterministic). To fix these problems, the encryption algorithm can either be randomized or stateful—it either flips coins during its execution, or its operation depends upon some state information. The decryption algorithm, however, is neither randomized nor stateful.</p> <p>There are several standard ways (or modes of operation) of building an encryption algorithm, using a block cipher:</p> <p><strong>ECB Mode</strong> (Electronic Code Book): In this mode the plaintext \(M\) is simply broken into \(n\)-bit blocks \(M_1 \cdots M_l\), and each block is encoded using the block cipher: \(C_i = E_K(M_i)\). The ciphertext is just a concatenation of these individual blocks: \(C = C_1 \cdot C_2 \cdots C_l\). This scheme is <strong>flawed</strong>. Any redundancy in the blocks will show through and allow the eavesdropper to deduce information about the plaintext. For instance, if \(M_i=M_j\), then we will have \(C_i=C_j\), which is visible to the eavesdropper; so ECB mode <strong>leaks information</strong> about the plaintext.</p> <ul> <li> <p>ECB mode encryption: \(C_i = E_K(M_i)\)</p> </li> <li> <p>ECB mode decryption: \(M_i = D_K(C_i)\)</p> </li> </ul> <p><img src="/assets/images/crypto/symmetric/ECB_encryption.png" alt="Diagram of encryption for the ECB mode of operation" /></p> <p><img src="/assets/images/crypto/symmetric/ECB_decryption.png" alt="Diagram of decryption for the ECB mode of operation" /></p> <p><strong>CBC Mode</strong> (Cipher Block Chaining): This is a popular mode for commercial applications. For each message the sender picks a random \(n\)-bit string, called the <em>initial vector</em> or IV. Define \(C_0 = IV\). The \(i^\textrm{th}\) ciphertext block is given by \(C_i = E_K(C_{i-1} \oplus M_i)\). The ciphertext is the concatenation of the initial vector and these individual blocks: \(C = IV \cdot C_1 \cdot C_2 \cdots C_l\). CBC mode has been proven to provide strong security guarantees on the privacy of the plaintext message (assuming the underlying block cipher is secure).</p> <ul> <li> <p>CBC mode encryption: \(\begin{cases} C_0 = IV \\ C_i = E_K(P_i \oplus C_{i-1}) \end{cases}\)</p> </li> <li> <p>CBC mode decryption: \(P_i = D_K(C_i) \oplus C_{i-1}\)</p> </li> </ul> <p><img src="/assets/images/crypto/symmetric/CBC_encryption.png" alt="Diagram of encryption for the CBC mode of operation" /></p> <p><img src="/assets/images/crypto/symmetric/CBC_decryption.png" alt="Diagram of decryption for the CBC mode of operation" /></p> <p><strong>CFB Mode</strong> (Ciphertext Feedback Mode): This is another popular mode with properties very similar to CBC mode. Again, \(C_0\) is the IV. The \(i^\textrm{th}\) ciphertext block is given by \(C_i = E_K(C_{i-1}) \oplus M_i\).</p> <ul> <li> <p>CFB mode encryption:</p> \[\begin{cases} C_0 = IV \\ C_i = E_K(C_{i-1}) \oplus P_i \end{cases}\] </li> <li> <p>CFB mode decryption: \(P_i = E_K(C_{i-1}) \oplus C_i\)</p> </li> </ul> <p><img src="/assets/images/crypto/symmetric/CFB_encryption.png" alt="Diagram of encryption for the CFB mode of operation" /></p> <p><img src="/assets/images/crypto/symmetric/CFB_decryption.png" alt="Diagram of decryption for the CFB mode of operation" /></p> <p><strong>OFB Mode</strong> (Output Feedback Mode): In this mode, the initial vector IV is repeatedly encrypted to obtain a set of values \(Z_i\) as follows: \(Z_0 = IV\) and \(Z_i = E_K(Z_{i-1})\). These values \(Z_i\) are now used as though they were the key for a one-time pad, so that \(C_i = Z_i \oplus M_i\). The ciphertext is the concatenation of the initial vector and these individual blocks: \(C = IV \cdot C_1 \cdot C_2 \cdots C_l\). In OFB mode, it is very easy to tamper with ciphertexts. For instance, suppose that the adversary happens to know that the \(j^\textrm{th}\) block of the message, \(M_j\), specifies the amount of money being transferred to his account from the bank, and suppose he also knows that \(M_j = 100\). Since he knows both \(M_j\) and \(C_j\), he can determine \(Z_j\). He can then substitute any \(n\)-bit block in place of \(M_j\) and get a new ciphertext \(C'_j\) where the \(100\) is replaced by any amount of his choice. This kind of tampering is also possible with other modes of operation as well (so don’t be fooled into thinking that CBC mode is safe from tampering); it’s just easier to illustrate on OFB mode.</p> <ul> <li> <p>OFB mode encryption:</p> \[\begin{cases} Z*0 = IV \\ Z_i = E_K(Z*{i-1}) \\ C_i = M_i \oplus Z_i \end{cases}\] </li> <li> <p>OFB mode decryption: \(P_i = C_i \oplus Z_i\)</p> </li> </ul> <p><img src="/assets/images/crypto/symmetric/OFB_encryption.png" alt="Diagram of encryption for the OFB mode of operation" /></p> <p><img src="/assets/images/crypto/symmetric/OFB_decryption.png" alt="Diagram of decryption for the OFB mode of operation" /></p> <p><strong>Counter (CTR) Mode</strong>: In CTR mode, a counter is initialized to IV and repeatedly incremented and encrypted to obtain a sequence that can now be used as though they were the keys for a one-time pad: namely, \(Z_i = E_K(IV + i)\) and \(C_i = Z_i \oplus M_i\). In CTR mode, the IV is sometimes renamed the <em>nonce</em>. This is just a terminology difference–nonce and IV can be used interchangeably for the purposes of this class.</p> <p>Note that in CTR and OFB modes, the decryption algorithm uses the block cipher <em>encryption</em> function instead of the decryption function. Intuitively, this is because Alice used the encryption function to generate a one-time pad, so Bob should also use the encryption function to generate the same pad. The plaintext is never passed through the block cipher encryption, so the block cipher decryption is never used.</p> <ul> <li> <p>CTR mode encryption: \(C_i = E_K(IV + i) \oplus M_i\)</p> </li> <li> <p>CTR mode decryption: \(M_i = E_K(IV + i) \oplus C_i\)</p> </li> </ul> <p><img src="/assets/images/crypto/symmetric/CTR_encryption.png" alt="Diagram of encryption for the CTR mode of operation" /></p> <p><img src="/assets/images/crypto/symmetric/CTR_decryption.png" alt="Diagram of decryption for the CTR mode of operation" /></p> <p>For the rest of these notes, we will focus on analyzing CBC and CTR modes. As an exercise, you can try performing similar analysis on the other modes as well.</p> <h2 id="67-parallelization"> <a href="#67-parallelization" class="anchor-heading" aria-labelledby="67-parallelization"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.7. Parallelization </h2> <p>In some modes, successive blocks must be encrypted or decrypted sequentially. In other words, to encrypt the \(i\)th block of plaintext, you first need to encrypt the \(i-1\)th block of plaintext and see the \(i-1\)th block of ciphertext output. For high-speed applications, it is often useful to parallelize encryption and decryption.</p> <p>Of the schemes described above, which ones have parallelizable encryption? Which ones have parallelizable decryption?</p> <p>CBC mode encryption cannot be parallelized. By examining the encryption equation \(C_i = E_K(P_i \oplus C_{i-1})\), we can see that to calculate \(C_i\), we first need to know the value of \(C_{i-1}\). In other words, we have to encrypt the \(i-1\)th block first before we can encrypt the \(i\)th block.</p> <p>CBC mode decryption can be parallelized. Again, we examine the decryption equation \(P_i = D_K(C_i) \oplus C_{i-1}\). To calculate \(P_i\), we need \(C_i\) and \(C_{i-1}\). Neither of these values need to be calculated–when we’re decrypting, we already have all of the ciphertext blocks. Thus we can compute all the \(P_i\) in parallel.</p> <p>CTR mode encryption and decryption can both be parallelized. To see this, we can examine the encryption and decryption diagrams. Note that each block cipher only takes the nonce and counter as input, and there is no reliance on any previous ciphertext or plaintext.</p> <h2 id="68-padding"> <a href="#68-padding" class="anchor-heading" aria-labelledby="68-padding"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.8. Padding </h2> <p>We have already reasoned that block ciphers let us encrypt messages that are longer than one block long. What happens if we want to send a message that is not a multiple of the block size? It turns out the answer depends on which mode is being used. For this section, assume that the block size is 128 bits, or 16 bytes (16 characters).</p> <p>In CBC mode, if the plaintext length isn’t a multiple of 128 bits, then the last block of plaintext will be slightly shorter than 128 bits. Then the XOR between the 128-bit previous ciphertext and the less-than-128-bit last block of plaintext would be undefined–bitwise XOR only works if the two inputs being XORed are the same length.</p> <p>Suppose the last block of plaintext is only 100 bits. What if we just XOR the first 100 bits of the previous ciphertext with the 100 bits of plaintext, and ignore the last 28 bits of the previous ciphertext? Now we have a 100-bit input to the block cipher, which only takes 128-bit inputs. This input is undefined for the block cipher.</p> <p>The solution to this problem is to add padding to the plaintext until it is a multiple of 128 bits.</p> <p>If we add padding to make the plaintext a multiple of 128 bits, we will need to be able to remove the padding later to correctly recover the original message. Some forms of padding can create ambiguity: for example, consider a padding scheme where we pad a message with all 1s. What happens if we need to pad a message <code class="language-plaintext highlighter-rouge">0000000010111</code>? We would add 1s until it’s a multiple of the block size, e.g. <code class="language-plaintext highlighter-rouge">0000000010111111</code>. When we try to depad the message, we run into some ambiguity. How many 1s do we remove from the end of the message? It’s unclear.</p> <p>One correct padding scheme is PKCS#7<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> padding. In this scheme, we pad the message by the number of padding bytes used. For example, the message above would be padded as <code class="language-plaintext highlighter-rouge">0000000010111333</code>, because 3 bytes of padding were needed. To remove the padding, we note that the message ends in a 3, so 3 bytes of padding were used, so we can unambiguously remove the last 3 bytes of padding. Note that if the message is already a multiple of a block size, an entire new block is appended. This way, there is always one unique padding pattern at the end of the message.</p> <p>Not all modes need padded plaintext input. For example, let’s look at CTR mode next. Again, suppose we only have 100 bits in your last block of plaintext. This time, we can actually XOR the 100 bits of plaintext with the first 100 bits of block cipher output, and ignore the last 28 bits of block cipher output. Why? Because the result of the XOR never has to be passed into a block cipher again, so we don’t care if it’s slightly shorter than 128 bits. The last ciphertext block will just end up being 100 bits instead of 128 bits, and that’s okay because it’s never used as an input to a block cipher.</p> <p>How does decryption work? From our encryption step, the last ciphertext block is only 100 bits instead of 128 bits. Then to retrieve the last 100 bits of plaintext, all we have to do is XOR the 100 bits of ciphertext with the first 100 bits of the block cipher output and ignore the last 28 bits of block cipher output.</p> <p>Recall that CTR mode can be thought of as generating a one-time pad through block ciphers. If the pad is too long, you can just throw away the last few bits of the pad in both the encryption and decryption steps.</p> <h2 id="69-reusing-ivs-is-insecure"> <a href="#69-reusing-ivs-is-insecure" class="anchor-heading" aria-labelledby="69-reusing-ivs-is-insecure"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.9. Reusing IVs is insecure </h2> <p>Remember that ECB mode is not IND-CPA secure because it is deterministic. Encrypting the same plaintext twice always results in the same output, and this causes information leakage. All the other modes introduce a random initialization vector (IV) that is different on every encryption in order to ensure that encrypting the same plaintext twice with the same key results in different output.</p> <p>This also means that when using secure block cipher modes, it is important to always choose a different, random, unpredictable IV for each new encryption. If the same IV is reused, the scheme becomes deterministic, and information is potentially leaked. The severity of information leakage depends on what messages are being encrypted and which mode is being used.</p> <p>For example, in CTR mode, reusing the IV (nonce) is equivalent to reusing the one-time pad. An attacker who sees two different messages encrypted with the same IV will know the bitwise XOR of the two messages. However, in CBC mode, reusing the IV on two different messages only reveals if two messages start with the same blocks, up until the first difference.</p> <p>Different modes have different tradeoffs between usability and security. Although proper use of CBC and CTR mode are both IND-CPA, insecure use of either mode (e.g. reusing the IV) breaks IND-CPA security, and the severity of information leakage is different in the two modes. In CBC mode, the information leakage is contained, but in CTR mode, the leakage is catastrophic (equivalent to reusing a one-time pad). On the other hand, CTR mode can be parallelized, but CBC can not, which is why many high performance systems use CTR mode or CTR-mode based encryption schemes.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Answer: Given \(M\) and \(C = M \oplus K\), Eve can calculate \(K = M \oplus C\). <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>This is why the only primary users of one-time-pads are spies in the field. Before the spy leaves, they obtain a large amount of key material. Unlike the other encryption systems we’ll see in these notes, a one-time pad can be processed entirely with pencil and paper. The spy then broadcasts messages encrypted with the one-time pad to send back to their home base. To obfuscate the spy’s communication, there are also “numbers stations” that continually broadcast meaningless sequences of random numbers. Since the one-time pad is IND-CPA secure, an adversary can’t distinguish between the random number broadcasts and the messages encoded with a one time pad. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>Answer: The key is needed to determine which scrambling setting was used to generate the ciphertext. If decryption didn’t require a key, any attacker would be able to decrypt encrypted messages! <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:4" role="doc-endnote"> <p>Fun fact: Professor David Wagner, who sometimes teaches this class, was part of the team that came up with a block cipher called <a href="https://en.wikipedia.org/wiki/Twofish">TwoFish</a>, which was one of the finalists in the NIST competition. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:5" role="doc-endnote"> <p>PKCS stands for Public Key Cryptography Standards. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
