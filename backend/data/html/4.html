<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>2. x86 Assembly and Call Stack - Computer Security</title> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>x86 Assembly and Call Stack | Computer Security</title> <meta name="generator" content="Jekyll v3.9.2" /> <meta property="og:title" content="x86 Assembly and Call Stack" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <meta property="og:description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <link rel="canonical" href="/memory-safety/x86.html" /> <meta property="og:url" content="/memory-safety/x86.html" /> <meta property="og:site_name" content="Computer Security" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="x86 Assembly and Call Stack" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Online textbook for CS 161: Computer Security at UC Berkeley.","headline":"x86 Assembly and Call Stack","url":"/memory-safety/x86.html"}</script> <!-- End Jekyll SEO tag --> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" ></script> <script> let toggleDark = () => { let setDark = jtd.getTheme() !== 'dark'; jtd.setTheme(setDark ? 'dark' : 'default'); localStorage.setItem('darkMode', String(setDark)); }; window.addEventListener('DOMContentLoaded', () => { /* Add event to dark mode button. */ let a = document.getElementsByClassName('site-button')[2]; a.addEventListener('click', (e) => { e.preventDefault(); toggleDark(); }); /* Read local storage state. */ if (localStorage.getItem('darkMode') === 'true') { toggleDark(); } }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/" class="site-title lh-tight"> Computer Security </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Introduction</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Security Principles category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/principles/" class="nav-list-link">Security Principles</a><ul class="nav-list "><li class="nav-list-item "><a href="/principles/principles.html" class="nav-list-link">1. Security Principles</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Memory Safety category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/memory-safety/" class="nav-list-link">Memory Safety</a><ul class="nav-list "><li class="nav-list-item active"><a href="/memory-safety/x86.html" class="nav-list-link active">2. x86 Assembly and Call Stack</a></li><li class="nav-list-item "><a href="/memory-safety/vulnerabilities.html" class="nav-list-link">3. Memory Safety Vulnerabilities</a></li><li class="nav-list-item "><a href="/memory-safety/mitigations.html" class="nav-list-link">4. Mitigating Memory-Safety Vulnerabilities</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Cryptography category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/crypto/" class="nav-list-link">Cryptography</a><ul class="nav-list "><li class="nav-list-item "><a href="/crypto/intro.html" class="nav-list-link">5. Introduction to Cryptography</a></li><li class="nav-list-item "><a href="/crypto/symmetric.html" class="nav-list-link">6. Symmetric-Key Cryptography</a></li><li class="nav-list-item "><a href="/crypto/hashes.html" class="nav-list-link">7. Cryptographic Hashes</a></li><li class="nav-list-item "><a href="/crypto/macs.html" class="nav-list-link">8. Message Authentication Codes (MACs)</a></li><li class="nav-list-item "><a href="/crypto/prng.html" class="nav-list-link">9. Pseudorandom Number Generators</a></li><li class="nav-list-item "><a href="/crypto/key-exchange.html" class="nav-list-link">10. Diffie-Hellman Key Exchange</a></li><li class="nav-list-item "><a href="/crypto/public-key.html" class="nav-list-link">11. Public-Key Encryption</a></li><li class="nav-list-item "><a href="/crypto/signatures.html" class="nav-list-link">12. Digital Signatures</a></li><li class="nav-list-item "><a href="/crypto/certificates.html" class="nav-list-link">13. Certificates</a></li><li class="nav-list-item "><a href="/crypto/passwords.html" class="nav-list-link">14. Passwords</a></li><li class="nav-list-item "><a href="/crypto/case-studies.html" class="nav-list-link">15. Case Studies</a></li><li class="nav-list-item "><a href="/crypto/bitcoin.html" class="nav-list-link">16. Bitcoin</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Web Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/web/" class="nav-list-link">Web Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/web/sqli.html" class="nav-list-link">17. SQL Injection</a></li><li class="nav-list-item "><a href="/web/intro.html" class="nav-list-link">18. Introduction to the Web</a></li><li class="nav-list-item "><a href="/web/sop.html" class="nav-list-link">19. Same-Origin Policy</a></li><li class="nav-list-item "><a href="/web/cookies.html" class="nav-list-link">20. Cookies and Session Management</a></li><li class="nav-list-item "><a href="/web/csrf.html" class="nav-list-link">21. Cross-Site Request Forgery (CSRF)</a></li><li class="nav-list-item "><a href="/web/xss.html" class="nav-list-link">22. Cross-Site Scripting (XSS)</a></li><li class="nav-list-item "><a href="/web/ui-attacks.html" class="nav-list-link">23. UI Attacks</a></li><li class="nav-list-item "><a href="/web/captchas.html" class="nav-list-link">24. CAPTCHAs</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Network Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/network/" class="nav-list-link">Network Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/network/intro.html" class="nav-list-link">25. Introduction to Networking</a></li><li class="nav-list-item "><a href="/network/arp.html" class="nav-list-link">26. ARP</a></li><li class="nav-list-item "><a href="/network/wpa.html" class="nav-list-link">27. WPA</a></li><li class="nav-list-item "><a href="/network/dhcp.html" class="nav-list-link">28. DHCP</a></li><li class="nav-list-item "><a href="/network/bgp.html" class="nav-list-link">29. BGP</a></li><li class="nav-list-item "><a href="/network/transport.html" class="nav-list-link">30. TCP and UDP</a></li><li class="nav-list-item "><a href="/network/tls.html" class="nav-list-link">31. TLS</a></li><li class="nav-list-item "><a href="/network/dns.html" class="nav-list-link">32. DNS</a></li><li class="nav-list-item "><a href="/network/dnssec.html" class="nav-list-link">33. DNSSEC</a></li><li class="nav-list-item "><a href="/network/dos.html" class="nav-list-link">34. Denial-of-Service (DoS)</a></li><li class="nav-list-item "><a href="/network/firewalls.html" class="nav-list-link">35. Firewalls</a></li><li class="nav-list-item "><a href="/network/intrusion-detection.html" class="nav-list-link">36. Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/abusing-intrusion-detection.html" class="nav-list-link">37. Abusing Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/malware.html" class="nav-list-link">38. Malware</a></li><li class="nav-list-item "><a href="/network/tor.html" class="nav-list-link">39. Anonymity and Tor</a></li></ul></li><li class="nav-list-item"><a href="/glossary.html" class="nav-list-link">Glossary</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Computer Security" aria-label="Search Computer Security" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://cs161.org" class="site-button" > CS 161 </a> </li> <li class="aux-nav-list-item"> <a href="#" class="site-button" > Dark Mode </a> </li> </ul> </nav> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/memory-safety/">Memory Safety</a></li> <li class="breadcrumb-nav-list-item"><span>2. x86 Assembly and Call Stack</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 id="2-x86-assembly-and-call-stack"> <a href="#2-x86-assembly-and-call-stack" class="anchor-heading" aria-labelledby="2-x86-assembly-and-call-stack"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2. x86 Assembly and Call Stack </h1> <p>This section reviews some relevant concepts from CS 61C and introduces x86 assembly, which is different from the RISC-V assembly taught in 61C.</p> <h2 id="21-number-representation"> <a href="#21-number-representation" class="anchor-heading" aria-labelledby="21-number-representation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.1. Number representation </h2> <p>At the lowest level, computers store memory as individual bits, where each bit is either 0 or 1. There are several units of measurement that we use for collections of bits:</p> <ul> <li>1 <em>nibble</em> = 4 bits</li> <li>1 <em>byte</em> = 8 bits</li> <li>1 <em>word</em> = 32 bits (on 32-bit architectures)</li> </ul> <p>A “word” is the size of a pointer, which depends on your CPU architecture. Real-world 64-bit architectures often include stronger defenses against memory safety exploits, so for ease of instruction, this class uses 32-bit architectures unless otherwise stated.</p> <p>For example, the string <code class="language-plaintext highlighter-rouge">1000100010001000</code> has 16 bits, or 4 nibbles, or 2 bytes.</p> <p>Sometimes we use hexadecimal as a shorthand for writing out long strings of bits. In hexadecimal shorthand, a nibble can be written as a single hexadecimal digit. The chart below shows conversions between nibbles written in binary and hexadecimal.</p> <div class="table-wrapper"><table> <thead> <tr> <th style="text-align: center">Binary</th> <th style="text-align: center">Hexadecimal</th> <th style="text-align: center">Binary</th> <th style="text-align: center">Hexadecimal</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">0000</td> <td style="text-align: center">0</td> <td style="text-align: center">1000</td> <td style="text-align: center">8</td> </tr> <tr> <td style="text-align: center">0001</td> <td style="text-align: center">1</td> <td style="text-align: center">1001</td> <td style="text-align: center">9</td> </tr> <tr> <td style="text-align: center">0010</td> <td style="text-align: center">2</td> <td style="text-align: center">1010</td> <td style="text-align: center">A</td> </tr> <tr> <td style="text-align: center">0011</td> <td style="text-align: center">3</td> <td style="text-align: center">1011</td> <td style="text-align: center">B</td> </tr> <tr> <td style="text-align: center">0100</td> <td style="text-align: center">4</td> <td style="text-align: center">1100</td> <td style="text-align: center">C</td> </tr> <tr> <td style="text-align: center">0101</td> <td style="text-align: center">5</td> <td style="text-align: center">1101</td> <td style="text-align: center">D</td> </tr> <tr> <td style="text-align: center">0110</td> <td style="text-align: center">6</td> <td style="text-align: center">1110</td> <td style="text-align: center">E</td> </tr> <tr> <td style="text-align: center">0111</td> <td style="text-align: center">7</td> <td style="text-align: center">1111</td> <td style="text-align: center">F</td> </tr> </tbody> </table></div> <p>To distinguish between binary and hexadecimal strings, we put <code class="language-plaintext highlighter-rouge">0b</code> before binary strings and <code class="language-plaintext highlighter-rouge">0x</code> before hexadecimal strings.</p> <p>Sanity check: Convert the binary string <code class="language-plaintext highlighter-rouge">0b1100000101100001</code> into hexadecimal.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p> <h2 id="22-compiler-assembler-linker-loader-call"> <a href="#22-compiler-assembler-linker-loader-call" class="anchor-heading" aria-labelledby="22-compiler-assembler-linker-loader-call"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.2. Compiler, Assembler, Linker, Loader (CALL) </h2> <p>Recall from 61C that there are four main steps to running a C program.</p> <ol> <li>The <em>compiler</em> translates your C code into assembly instructions. 61C uses the RISC-V instruction set, but in 161, we use x86, which is more commonly seen in the real world.</li> <li>The <em>assembler</em> translates the assembly instructions from the compiler into machine code (raw bits). You might remember using the RISC-V green sheet to translate assembly instructions into raw bits in 61C. This is what the assembler does.</li> <li>The <em>linker</em> resolves dependencies on external libraries. After the linker is finished linking external libraries, it outputs a binary executable of the program that you can run (you can mostly ignore the linker for the purposes of 161).</li> <li>When the user runs the executable, the <em>loader</em> sets up an address space in memory and runs the machine code instructions in the executable.</li> </ol> <h2 id="23-c-memory-layout"> <a href="#23-c-memory-layout" class="anchor-heading" aria-labelledby="23-c-memory-layout"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.3. C memory layout </h2> <p>At runtime, the operating system gives the program an address space to store any state necessary for program execution. You can think of the address space as a large, contiguous chunk of memory. Each <em>byte</em> of memory has a unique address.</p> <p>The size of the address space depends on your operating system and CPU architecture. In a 32-bit system, memory addresses are 32 bits long, which means the address space has \(2^{32}\) bytes of memory. In a 64-bit system, memory addresses are 64 bits long. (Sanity check: how big is the address space in this system?<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>) In this class, unless otherwise stated we’ll be using 32-bit systems.</p> <p>We can draw the memory layout as one long array with \(2^{32}\) elements, where each element is one byte. The leftmost element has address <code class="language-plaintext highlighter-rouge">0x00000000</code>, and the rightmost element has address <code class="language-plaintext highlighter-rouge">0xFFFFFFFF</code>.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p> <p><img src="/assets/images/memory-safety/x86/1d-address-space.png" alt="1-dimensional address space" /></p> <p>However, this is hard to read, so we usually draw memory as a grid of bytes. In the grid, the bottom-left element has address <code class="language-plaintext highlighter-rouge">0x00000000</code>, and the top-right element has address <code class="language-plaintext highlighter-rouge">0xFFFFFFFF</code>. Addresses increase as you move from left to right and from bottom to top.</p> <p><img src="/assets/images/memory-safety/x86/2d-address-space.png" alt="2-dimensional address space" /></p> <p>Although we can draw memory as a grid with annotations and labels, remember that the program only sees a huge array of raw bytes. It is up to the programmer and the compiler to manipulate this chunk of raw bytes to create objects like variables, pointers, arrays, and structs.</p> <p>When a program is being run, the address space is divided into four sections. From lowest address to highest address, they are:</p> <ul> <li>The <em>code</em> section contains the executable instructions of the program (i.e. the code itself). Recall that the assembler and linker output raw bytes that can be interpreted as machine code. These bytes are stored in the code section.</li> <li>The <em>static</em> section contains constants and static variables that never change during program execution, and are usually allocated when the program is started.</li> <li>The <em>heap</em> stores dynamically allocated data. When you call <code class="language-plaintext highlighter-rouge">malloc</code> in C, memory is allocated on the heap and given to you for use until you call <code class="language-plaintext highlighter-rouge">free</code>. The heap starts at lower addresses and “grows up” to higher addresses as more memory is allocated.</li> <li>The <em>stack</em> stores local variables and other information associated with function calls. The stack starts at higher addresses and “grows down” as more functions are called.</li> </ul> <p><img src="/assets/images/memory-safety/x86/memory-sections.png" alt="Memory Sections" /></p> <h2 id="24-little-endian-words"> <a href="#24-little-endian-words" class="anchor-heading" aria-labelledby="24-little-endian-words"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.4. Little-endian words </h2> <p>x86 is a <em>little-endian</em> system. This means that when storing a word in memory, the least significant byte is stored at the lowest address, and the most significant byte is stored at the highest address. For example, here we are storing the word <code class="language-plaintext highlighter-rouge">0x44332211</code> in memory:</p> <p><img src="/assets/images/memory-safety/x86/little-endian.png" alt="Little-endian word format" /></p> <p>Note that the least significant byte <code class="language-plaintext highlighter-rouge">0x11</code> is stored at the lowest address, and the most significant byte <code class="language-plaintext highlighter-rouge">0x44</code> is stored at the highest address.</p> <p>Because we work with words so often, sometimes we will write words on the memory diagram instead of individual bytes. Each word is 4 bytes, so each row of the diagram has exactly one word.</p> <p>Using words on the diagram lets us abstract away little-endianness when working with memory diagrams. However, it’s important to remember that the bytes are actually being stored in little-endian format.</p> <h2 id="25-registers"> <a href="#25-registers" class="anchor-heading" aria-labelledby="25-registers"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.5. Registers </h2> <p>In addition to the \(2^{32}\) bytes of memory in the address space, there are also <em>registers</em>, which store memory directly on the CPU. Each register can store one word (4 bytes). Unlike memory, registers do not have addresses. Instead, we refer to registers using names. There are three special x86 registers that are relevant for these notes:</p> <ul> <li><em>eip</em> is the <em>instruction pointer</em>, and it stores the address of the machine instruction currently being executed. In RISC-V, this register is called the PC (program counter).</li> <li><em>ebp</em> is the <em>base pointer</em>, and it stores the address of the top of the current stack frame. In RISC systems, this register is called the <code class="language-plaintext highlighter-rouge">FP</code> (frame pointer)<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>.</li> <li><em>esp</em> is the <em>stack pointer</em>, and it stores the address of the bottom of the current stack frame. In RISC-V, this register is called the <code class="language-plaintext highlighter-rouge">SP</code> (stack pointer).</li> </ul> <p>Note that the top of the current stack frame is the highest address associated with the current stack frame, and the bottom of the stack frame is the lowest address associated with the current stack frame.</p> <p>If you’re curious, the e in the register abbreviations stands for “extended” and indicates that we are using a 32-bit system (extended from the original 16-bit systems).</p> <p>Since the values in these three registers are usually addresses, sometimes we will say that a register <em>points</em> somewhere in memory. This means that the address stored in the register is the address of that location in memory. For example, if we say eip is pointing to <code class="language-plaintext highlighter-rouge">0xDEADBEEF</code>, this means that the eip register is storing the value <code class="language-plaintext highlighter-rouge">0xDEADBEEF</code>, which can be interpreted as an address to refer to a location in memory.</p> <p>Sanity check: Which section of C memory (code, static, heap, stack) do each of these registers usually point to?<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p> <h2 id="26-stack-pushing-and-popping"> <a href="#26-stack-pushing-and-popping" class="anchor-heading" aria-labelledby="26-stack-pushing-and-popping"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.6. Stack: Pushing and popping </h2> <p>Sometimes we want to remember a value by saving it on the stack. There are two steps to adding a value on the stack. First, we have to allocate additional space on the stack by decrementing the esp. Then, we store the value in the newly allocated space. The x86 <code class="language-plaintext highlighter-rouge">push</code> instruction does both of these steps to add a value to the stack.</p> <p><img src="/assets/images/memory-safety/x86/push.png" alt="Before and after of pushing an item onto the stack" /></p> <p>We may also want to remove values from the stack. The x86 <code class="language-plaintext highlighter-rouge">pop</code> instruction increments esp to remove the next value on the stack. It also takes the value that was just popped and copies the value into a register.</p> <p>Note that when we pop a value off the stack, the value is not wiped away from memory. However, we increment esp so that the popped value is now below esp. The esp register points to the bottom of the stack, so the popped value below esp is now in undefined memory.</p> <p><img src="/assets/images/memory-safety/x86/pop.png" alt="Before and after of popping an item off the stack" /></p> <p>(eax and ebx are general-purpose registers in x86. We use them here as an example of pushing and popping from the stack, but you don’t need to know anything else about these registers.)</p> <h2 id="27-x86-calling-convention"> <a href="#27-x86-calling-convention" class="anchor-heading" aria-labelledby="27-x86-calling-convention"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.7. x86 calling convention </h2> <p>This class uses AT&amp;T x86 syntax (since that is what GDB uses). This means that the destination register comes last; note that this is in contrast with RISC-V assembly, where the destination register comes first. Suppose our assembly instruction was <code class="language-plaintext highlighter-rouge">addl $0x8, %ebx</code>; here, the opcode is <code class="language-plaintext highlighter-rouge">addl</code>, the source is <code class="language-plaintext highlighter-rouge">$0x8</code>, and the destination is <code class="language-plaintext highlighter-rouge">%ebx</code>, so in pseudocode this can be read as <code class="language-plaintext highlighter-rouge">EBX = EBX + 0x8</code>.</p> <p>References to registers are preceded with a percent sign, so if we wanted to reference <code class="language-plaintext highlighter-rouge">eax</code>, we would do so as <code class="language-plaintext highlighter-rouge">%eax</code>. Immediates are preceded with a dollar sign (i.e. $1, $0x4, etc.). Furthermore, memory references use parenthesis and can have immediate offsets; for example, <code class="language-plaintext highlighter-rouge">12(%esp)</code> dereferences memory 12 bytes above the address contained in ESP. If parentheses are used without an immediate offset, the offset can be thought of as an implicit 0.</p> <p>Suppose our assembly instruction was <code class="language-plaintext highlighter-rouge">xorl 4(%esi), %eax</code>; here, the opcode is <code class="language-plaintext highlighter-rouge">xorl</code>, the source is <code class="language-plaintext highlighter-rouge">4(%esi)</code>, and the destination is <code class="language-plaintext highlighter-rouge">%eax</code>. As such, in pseudocode, this can be written as <code class="language-plaintext highlighter-rouge">EAX = EAX ^ *(ESI + 4)</code>. Since this is a memory reference, we are dereferencing the value 4 bytes above the address stored in ESI.</p> <h2 id="28-x86-function-calls"> <a href="#28-x86-function-calls" class="anchor-heading" aria-labelledby="28-x86-function-calls"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.8. x86 function calls </h2> <p>When a function is called, the stack allocates extra space to store local variables and other information relevant to that function. Recall that the stack grows down, so this extra space will be at lower addresses in memory. Once the function returns, the space on the stack is freed up for future function calls. This section explains the steps of a function call in x86.</p> <p>Recall that in a function call, the <em>caller</em> calls the <em>callee</em>. Program execution starts in the caller, moves to the callee as a result of the function call, and then returns to the caller after the function call completes.</p> <p>When we call a function in x86, we need to update the values in all three registers we’ve discussed:</p> <ul> <li>eip, the instruction pointer, is currently pointing at the instructions of the caller. It needs to be changed to point to the instructions of the callee.</li> <li>ebp and esp currently point to the top and bottom of the caller stack frame, respectively. Both registers need to be updated to point to the top and bottom of a new stack frame for the callee.</li> </ul> <p>When the function returns, we want to restore the old values in the registers so that we can go back to executing the caller. <em>When we update the value of a register, we need to save its old value on the stack so we can restore the old value after the function returns.</em></p> <p>There are 11 steps to calling an x86 function and returning. In this example, <code class="language-plaintext highlighter-rouge">main</code> is the caller function and <code class="language-plaintext highlighter-rouge">foo</code> is the callee function. In other words, <code class="language-plaintext highlighter-rouge">main</code> calls the <code class="language-plaintext highlighter-rouge">foo</code> function.</p> <p>Here is the stack before the function is called. ebp and esp point to the top and bottom of the caller stack frame.</p> <p><img src="/assets/images/memory-safety/x86/stack0.png" alt="Initial stack diagram, with a stack frame for main at the top" /></p> <p><strong>1. Push arguments onto the stack.</strong> RISC-V passes arguments by storing them in registers, but x86 passes arguments by pushing them onto the stack. Note that esp is decremented as we push arguments onto the stack. Arguments are pushed onto the stack in reverse order.</p> <p><img src="/assets/images/memory-safety/x86/stack1.png" alt="Next stack diagram, with argument 2 pushed below the stack frame for main and argument 1 pushed below argument 2" /></p> <p><strong>2. Push the old eip (rip) on the stack.</strong> We are about to change the value in the eip register, so we need to save its current value on the stack before we overwrite it with a new value. When we push this value on the stack, it is called the <em>old eip</em> or the <em>rip</em> (return instruction pointer).<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p> <p><img src="/assets/images/memory-safety/x86/stack2.png" alt="Next stack diagram, with the old eip pushed below argument 1" /></p> <p><strong>3. Move eip.</strong> Now that we’ve saved the old value of eip, we can safely change eip to point to the instructions for the callee function.</p> <p><img src="/assets/images/memory-safety/x86/stack3.png" alt="Next stack diagram, with the eip moved to the code for foo" /></p> <p><strong>4. Push the old ebp (sfp) on the stack.</strong> We are about to change the value in the ebp register, so we need to save its current value on the stack before we overwrite it with a new value. When we push this value on the stack, it is called the <em>old ebp</em> or the <em>sfp</em> (saved frame pointer). Note that esp has been decremented because we pushed a new value on the stack.</p> <p><img src="/assets/images/memory-safety/x86/stack4.png" alt="Next stack diagram, with the old ebp pushed below the old eip" /></p> <p><strong>5. Move ebp down.</strong> Now that we’ve saved the old value of ebp, we can safely change ebp to point to the top of the new stack frame. The top of the new stack frame is where esp is currently pointing, since we are about to allocate new space below esp for the new stack frame.</p> <p><img src="/assets/images/memory-safety/x86/stack5.png" alt="Next stack diagram, with the ebp moved to the esp" /></p> <p><strong>6. Move esp down.</strong> Now we can allocate new space for the new stack frame by decrementing esp. The compiler looks at the complexity of the function to determine how far esp should be decremented. For example, a function with only a few local variables doesn’t require too much space on the stack, so esp will only be decremented by a few bytes. On the other hand, if a function declares a large array as a local variable, esp will need to be decremented by a lot to fit the array on the stack.</p> <p><img src="/assets/images/memory-safety/x86/stack6.png" alt="Next stack diagram, with the esp down by 8 bytes" /></p> <p><strong>7. Execute the function.</strong> Local variables and any other necessary data can now be saved in the new stack frame. Additionally, since ebp is always pointing at the top of the stack frame, we can use it as a point of reference to find other variables on the stack. For example, the arguments will be located starting at the address stored in ebp, plus 8.</p> <p><img src="/assets/images/memory-safety/x86/stack7.png" alt="Next stack diagram, with the 8 bytes previously allocated now having been used for local variables" /></p> <p><strong>8. Move esp up.</strong> Once the function is ready to return, we increment esp to point to the top of the stack frame (ebp). This effectively erases the stack frame, since the stack frame is now located below esp. (Anything on the stack below esp is undefined.)</p> <p><img src="/assets/images/memory-safety/x86/stack8.png" alt="Next stack diagram, with the esp moved back up by 8 bytes" /></p> <p><strong>9. Restore the old ebp (sfp)</strong>. The next value on the stack is the sfp, the old value of ebp before we started executing the function. We pop the sfp off the stack and store it back into the ebp register. This returns ebp to its old value before the function was called.</p> <p><img src="/assets/images/memory-safety/x86/stack9.png" alt="Next stack diagram, with the old ebp popped off the stack and the ebp moved to its location" /></p> <p><strong>10. Restore the old eip (rip)</strong>. The next value on the stack is the rip, the old value of eip before we started executing the function. We pop the rip off the stack and store it back into the eip register. This returns eip to its old value before the function was called.<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup></p> <p><img src="/assets/images/memory-safety/x86/stack10.png" alt="Next stack diagram, with the old eip popped off the stack and the eip moved to its location" /></p> <p><strong>11. Remove arguments from the stack.</strong> Since the function call is over, we don’t need to store the arguments anymore. We can remove them by incrementing esp (recall that anything on the stack below esp is undefined).</p> <p><img src="/assets/images/memory-safety/x86/stack11.png" alt="Next stack diagram, with the esp moved up by 8 bytes to now be above the arguments" /></p> <p>You might notice that we saved the old values of eip and ebp during the function call, but not the old value of esp. A nice consequence of this function call design is that esp will automatically move to the bottom of the stack as we push values onto the stack and automatically return to its old position as we remove values from the stack. As a result, there is no need to save the old value of esp during the function call.</p> <h2 id="29-x86-function-call-in-assembly"> <a href="#29-x86-function-call-in-assembly" class="anchor-heading" aria-labelledby="29-x86-function-call-in-assembly"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.9. x86 function call in assembly </h2> <p>Consider the following C code:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(void) {
    foo(1, 2);
}

void foo(int a, int b) {
    int bar[4];
}
</code></pre></div></div> <p>The compiler would turn the <code class="language-plaintext highlighter-rouge">foo</code> function call into the following assembly instructions:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main:
    # Step 1. Push arguments on the stack in reverse order
    push $2
    push $1

    # Steps 2-3. Save old eip (rip) on the stack and change eip
    call foo

    # Execution changes to foo now. After returning from foo:

    # Step 11: Remove arguments from stack
    add $8, %esp

foo:
    # Step 4. Push old ebp (sfp) on the stack
    push %ebp

    # Step 5. Move ebp down to esp
    mov %esp, %ebp

    # Step 6. Move esp down
    sub $16, %esp

    # Step 7. Execute the function (omitted here)

    # Step 8. Move esp
    mov %ebp, %esp

    # Step 9. Restore old ebp (sfp)
    pop %ebp

    # Step 10. Restore old eip (rip)
    pop %eip
</code></pre></div></div> <p>Note that steps 1-3 happen in the caller function (<code class="language-plaintext highlighter-rouge">main</code>). Step 3 is changing the eip to point to the callee function (<code class="language-plaintext highlighter-rouge">foo</code>). Once the eip is changed, program execution is now in <code class="language-plaintext highlighter-rouge">foo</code>, where steps 4-10 take place. Step 10 is changing the eip to point back to the caller function (<code class="language-plaintext highlighter-rouge">main</code>). Once the eip is changed back, program execution is now in <code class="language-plaintext highlighter-rouge">main</code>, where step 11 takes place.</p> <p>The <code class="language-plaintext highlighter-rouge">call</code> instruction in steps 2-3 pushes the old eip (rip) onto the stack and then changes eip to point to the instructions for the <code class="language-plaintext highlighter-rouge">foo</code> function.</p> <p>In step 6, esp is moved down by 16 bytes. The number 16 is determined by the compiler depending on the function being called. In this case, the compiler decides 16 bytes are required to fit the local variable and any other data needed for the function to execute.</p> <p>This class uses AT&amp;T x86 syntax, which means in the <code class="language-plaintext highlighter-rouge">mov</code> instruction, the source is the first argument, and the destination is the second argument. For example, step 5, <code class="language-plaintext highlighter-rouge">mov %esp, %ebp</code> says to take the value in esp and put it in ebp.<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup></p> <p>Since function calls are so common, assembly programmers sometimes use shorthand to write function returns. The two instructions in steps 8 and 9 are sometimes abbreviated as the <code class="language-plaintext highlighter-rouge">leave</code> instruction, and the instruction in step 10 is sometimes abbreviated as the <code class="language-plaintext highlighter-rouge">ret</code> instruction. This lets x86 programmers simply write “<code class="language-plaintext highlighter-rouge">leave ret</code>” after each function.</p> <p>Steps 4-6 are sometimes called the <em>function prologue</em>, since they must appear at the start of the assembly code of any C function. Similarly, steps 8-10 are sometimes called the <em>function epilogue</em>.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Answer: Using the table to look up each sequence of 4 bits, we get <code class="language-plaintext highlighter-rouge">0xC161</code>. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>Answer: \(2^{64}\) bytes. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>In reality your program may not have all this memory, but the operating system gives the program the illusion that it has access to all this memory. Refer to the virtual memory unit in CS 61C or take CS 162 to learn more. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:4" role="doc-endnote"> <p>RISC systems often omit this register because it is not necessary with the RISC stack design. For example, in RISC-V, <code class="language-plaintext highlighter-rouge">FP</code> is sometimes renamed <code class="language-plaintext highlighter-rouge">s0</code> and used as a general-purpose register <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:5" role="doc-endnote"> <p>Answer: eip points to the code section, where instructions are stored. ebp and esp point to the stack section. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:6" role="doc-endnote"> <p>In reality, the value we push on the stack is the current value in eip, incremented by 1 instruction. This is because after the function returns, we want to execute the instruction directly after the instruction eip is currently pointing to. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:7" role="doc-endnote"> <p>In reality, eip is now pointing at the instruction directly after the old instruction it was pointing to. This lets us continue executing the caller function right after where we left off to call the function. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:8" role="doc-endnote"> <p>Note that if you are searching for x86 resources online, you may run into Intel syntax, where the source and destination are reversed. Percent signs <code class="language-plaintext highlighter-rouge">%</code> usually mean you’re reading AT&amp;T syntax. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
