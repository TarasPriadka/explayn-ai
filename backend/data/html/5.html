<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>3. Memory Safety Vulnerabilities - Computer Security</title> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Memory Safety Vulnerabilities | Computer Security</title> <meta name="generator" content="Jekyll v3.9.2" /> <meta property="og:title" content="Memory Safety Vulnerabilities" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <meta property="og:description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <link rel="canonical" href="/memory-safety/vulnerabilities.html" /> <meta property="og:url" content="/memory-safety/vulnerabilities.html" /> <meta property="og:site_name" content="Computer Security" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Memory Safety Vulnerabilities" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Online textbook for CS 161: Computer Security at UC Berkeley.","headline":"Memory Safety Vulnerabilities","url":"/memory-safety/vulnerabilities.html"}</script> <!-- End Jekyll SEO tag --> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" ></script> <script> let toggleDark = () => { let setDark = jtd.getTheme() !== 'dark'; jtd.setTheme(setDark ? 'dark' : 'default'); localStorage.setItem('darkMode', String(setDark)); }; window.addEventListener('DOMContentLoaded', () => { /* Add event to dark mode button. */ let a = document.getElementsByClassName('site-button')[2]; a.addEventListener('click', (e) => { e.preventDefault(); toggleDark(); }); /* Read local storage state. */ if (localStorage.getItem('darkMode') === 'true') { toggleDark(); } }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/" class="site-title lh-tight"> Computer Security </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Introduction</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Security Principles category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/principles/" class="nav-list-link">Security Principles</a><ul class="nav-list "><li class="nav-list-item "><a href="/principles/principles.html" class="nav-list-link">1. Security Principles</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Memory Safety category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/memory-safety/" class="nav-list-link">Memory Safety</a><ul class="nav-list "><li class="nav-list-item "><a href="/memory-safety/x86.html" class="nav-list-link">2. x86 Assembly and Call Stack</a></li><li class="nav-list-item active"><a href="/memory-safety/vulnerabilities.html" class="nav-list-link active">3. Memory Safety Vulnerabilities</a></li><li class="nav-list-item "><a href="/memory-safety/mitigations.html" class="nav-list-link">4. Mitigating Memory-Safety Vulnerabilities</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Cryptography category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/crypto/" class="nav-list-link">Cryptography</a><ul class="nav-list "><li class="nav-list-item "><a href="/crypto/intro.html" class="nav-list-link">5. Introduction to Cryptography</a></li><li class="nav-list-item "><a href="/crypto/symmetric.html" class="nav-list-link">6. Symmetric-Key Cryptography</a></li><li class="nav-list-item "><a href="/crypto/hashes.html" class="nav-list-link">7. Cryptographic Hashes</a></li><li class="nav-list-item "><a href="/crypto/macs.html" class="nav-list-link">8. Message Authentication Codes (MACs)</a></li><li class="nav-list-item "><a href="/crypto/prng.html" class="nav-list-link">9. Pseudorandom Number Generators</a></li><li class="nav-list-item "><a href="/crypto/key-exchange.html" class="nav-list-link">10. Diffie-Hellman Key Exchange</a></li><li class="nav-list-item "><a href="/crypto/public-key.html" class="nav-list-link">11. Public-Key Encryption</a></li><li class="nav-list-item "><a href="/crypto/signatures.html" class="nav-list-link">12. Digital Signatures</a></li><li class="nav-list-item "><a href="/crypto/certificates.html" class="nav-list-link">13. Certificates</a></li><li class="nav-list-item "><a href="/crypto/passwords.html" class="nav-list-link">14. Passwords</a></li><li class="nav-list-item "><a href="/crypto/case-studies.html" class="nav-list-link">15. Case Studies</a></li><li class="nav-list-item "><a href="/crypto/bitcoin.html" class="nav-list-link">16. Bitcoin</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Web Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/web/" class="nav-list-link">Web Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/web/sqli.html" class="nav-list-link">17. SQL Injection</a></li><li class="nav-list-item "><a href="/web/intro.html" class="nav-list-link">18. Introduction to the Web</a></li><li class="nav-list-item "><a href="/web/sop.html" class="nav-list-link">19. Same-Origin Policy</a></li><li class="nav-list-item "><a href="/web/cookies.html" class="nav-list-link">20. Cookies and Session Management</a></li><li class="nav-list-item "><a href="/web/csrf.html" class="nav-list-link">21. Cross-Site Request Forgery (CSRF)</a></li><li class="nav-list-item "><a href="/web/xss.html" class="nav-list-link">22. Cross-Site Scripting (XSS)</a></li><li class="nav-list-item "><a href="/web/ui-attacks.html" class="nav-list-link">23. UI Attacks</a></li><li class="nav-list-item "><a href="/web/captchas.html" class="nav-list-link">24. CAPTCHAs</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Network Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/network/" class="nav-list-link">Network Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/network/intro.html" class="nav-list-link">25. Introduction to Networking</a></li><li class="nav-list-item "><a href="/network/arp.html" class="nav-list-link">26. ARP</a></li><li class="nav-list-item "><a href="/network/wpa.html" class="nav-list-link">27. WPA</a></li><li class="nav-list-item "><a href="/network/dhcp.html" class="nav-list-link">28. DHCP</a></li><li class="nav-list-item "><a href="/network/bgp.html" class="nav-list-link">29. BGP</a></li><li class="nav-list-item "><a href="/network/transport.html" class="nav-list-link">30. TCP and UDP</a></li><li class="nav-list-item "><a href="/network/tls.html" class="nav-list-link">31. TLS</a></li><li class="nav-list-item "><a href="/network/dns.html" class="nav-list-link">32. DNS</a></li><li class="nav-list-item "><a href="/network/dnssec.html" class="nav-list-link">33. DNSSEC</a></li><li class="nav-list-item "><a href="/network/dos.html" class="nav-list-link">34. Denial-of-Service (DoS)</a></li><li class="nav-list-item "><a href="/network/firewalls.html" class="nav-list-link">35. Firewalls</a></li><li class="nav-list-item "><a href="/network/intrusion-detection.html" class="nav-list-link">36. Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/abusing-intrusion-detection.html" class="nav-list-link">37. Abusing Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/malware.html" class="nav-list-link">38. Malware</a></li><li class="nav-list-item "><a href="/network/tor.html" class="nav-list-link">39. Anonymity and Tor</a></li></ul></li><li class="nav-list-item"><a href="/glossary.html" class="nav-list-link">Glossary</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Computer Security" aria-label="Search Computer Security" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://cs161.org" class="site-button" > CS 161 </a> </li> <li class="aux-nav-list-item"> <a href="#" class="site-button" > Dark Mode </a> </li> </ul> </nav> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/memory-safety/">Memory Safety</a></li> <li class="breadcrumb-nav-list-item"><span>3. Memory Safety Vulnerabilities</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 id="3-memory-safety-vulnerabilities"> <a href="#3-memory-safety-vulnerabilities" class="anchor-heading" aria-labelledby="3-memory-safety-vulnerabilities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3. Memory Safety Vulnerabilities </h1> <h2 id="31-buffer-overflow-vulnerabilities"> <a href="#31-buffer-overflow-vulnerabilities" class="anchor-heading" aria-labelledby="31-buffer-overflow-vulnerabilities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.1. Buffer overflow vulnerabilities </h2> <p>We’ll start our discussion of vulnerabilities with one of the most common types of errors — <em>buffer overflow</em> (also called <em>buffer overrun</em>) vulnerabilities. Buffer overflow vulnerabilities are a particular risk in C, and since C is an especially widely used systems programming language, you might not be surprised to hear that buffer overflows are one of the most pervasive kind of implementation flaws around. However, buffer overflows are not unique to C, as C++ and Objective-C both suffer from these vulnerabilities as well.</p> <p>C is a low-level language, meaning that the programmer is always exposed to the bare machine, one of the reasons why C is such a popular systems language. Furthermore, C is also a very old language, meaning that there are several legacy systems, which are old codebases written in C that are still maintained and updated. A particular weakness that we will discuss is the absence of automatic bounds-checking for array or pointer accesses. For example, if the programmer declares an array <code class="language-plaintext highlighter-rouge">char buffer[4]</code>, C will not automatically throw an error if the programmer tries to access <code class="language-plaintext highlighter-rouge">buffer[5]</code>. It is the programmer’s responsibility to carefully check that every memory access is in bounds. This can get difficult as your code gets more and more complicated (e.g. for loops, user inputs, multi-threaded programs).</p> <p>It is through this absence of automatic bounds-checking that buffer overflows take advantage of. A buffer overflow bug is one where the programmer fails to perform adequate bounds checks, triggering an out-of-bounds memory access that writes beyond the bounds of some memory region. Attackers can use these out-of-bounds memory accesses to corrupt the program’s intended behavior.</p> <p>Let us start with a simple example.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char buf[8];
void vulnerable() {
    gets(buf);
}
</code></pre></div></div> <p>In this example, <code class="language-plaintext highlighter-rouge">gets()</code> reads as many bytes of input as the user supplies (through standard input), and stores them into <code class="language-plaintext highlighter-rouge">buf[]</code>. If the input contains more than 8 bytes of data, then <code class="language-plaintext highlighter-rouge">gets()</code> will write past the end of <code class="language-plaintext highlighter-rouge">buf</code>, overwriting some other part of memory. This is a bug.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/overflow1.png" alt="Two words of memory for buf overwritten and two more words of memory above it overwritten" /></p> <p>Note that <code class="language-plaintext highlighter-rouge">char buf[8]</code> is defined outside of the function, so it is located in the static part of memory. Also note that each row of the diagram represents 4 bytes, so <code class="language-plaintext highlighter-rouge">char buf[8]</code> takes up 2 rows.</p> <p><code class="language-plaintext highlighter-rouge">gets(buf)</code> writes user input from lower addresses to higher addresses, starting at <code class="language-plaintext highlighter-rouge">buf</code>, and since there is no bounds checking, the attacker can overwrite parts of memory at addresses higher than <code class="language-plaintext highlighter-rouge">buf</code>.</p> <p>To illustrate some of the dangers that this bug can cause, let’s slightly modify the example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char buf[8];
int authenticated = 0;
void vulnerable() {
    gets(buf);
}
</code></pre></div></div> <p>Note that both <code class="language-plaintext highlighter-rouge">char buf[8]</code> and <code class="language-plaintext highlighter-rouge">authenticated</code> are defined outside of the function, so they are both located in the static part of memory. In C, static memory is filled in the order that variables are defined, so <code class="language-plaintext highlighter-rouge">authenticated</code> is at a higher address in memory than <code class="language-plaintext highlighter-rouge">buf</code> (since static memory grows upward and <code class="language-plaintext highlighter-rouge">buf</code> was defined first, <code class="language-plaintext highlighter-rouge">buf</code> is at a lower memory address).</p> <p>Imagine that elsewhere in the code, there is a login routine that sets the <code class="language-plaintext highlighter-rouge">authenticated</code> flag only if the user proves knowledge of the password. Unfortunately, the <code class="language-plaintext highlighter-rouge">authenticated</code> flag is stored in memory right after <code class="language-plaintext highlighter-rouge">buf</code>. Note that we use “after” here to mean “at a higher memory address”.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/overflow2.png" alt="Two words of memory for buf overwritten and an authenticated above it overwritten" /></p> <p>If the attacker can write 9 bytes of data to <code class="language-plaintext highlighter-rouge">buf</code> (with the 9th byte set to a non-zero value), then this will set the <code class="language-plaintext highlighter-rouge">authenticated</code> flag to true, and the attacker will be able to gain access.</p> <p>The program above allows that to happen, because the <code class="language-plaintext highlighter-rouge">gets</code> function does no bounds-checking; it will write as much data to <code class="language-plaintext highlighter-rouge">buf</code> as is supplied to it by the user. In other words, the code above is <em>vulnerable</em>: an attacker who can control the input to the program can bypass the password checks.</p> <p>Now consider another variation:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char buf[8];
int (*fnptr)();
void vulnerable() {
    gets(buf);
}
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">fnptr</code> is a <em>function pointer</em>. In memory, this is a 4-byte value that stores the address of a function. In other words, calling <code class="language-plaintext highlighter-rouge">fnptr</code> will cause the program to dereference the pointer and start executing instructions at that address.</p> <p>Like <code class="language-plaintext highlighter-rouge">authenticated</code> in the previous example, <code class="language-plaintext highlighter-rouge">fnptr</code> is stored directly above <code class="language-plaintext highlighter-rouge">buf</code> in memory.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/overflow3.png" alt="Two words of memory for buf overwritten and a function pointer above it overwritten" /></p> <p>Suppose the function pointer <code class="language-plaintext highlighter-rouge">fnptr</code> is called elsewhere in the program (not shown). This enables a more serious attack: the attacker can overwrite <code class="language-plaintext highlighter-rouge">fnptr</code> with any address of their choosing, redirecting program execution to some other memory location.</p> <p>Notice that in this attack, the attacker can choose to overwrite <code class="language-plaintext highlighter-rouge">fnptr</code> with any address of their choosing—so, for instance, they can choose to overwrite <code class="language-plaintext highlighter-rouge">fnptr</code> with an address where some malicious machine instructions are stored. This is a <em>malicious code injection</em> attack.</p> <p>Of course, many variations on this attack are possible: the attacker could store malicious code anywhere in memory and redirect execution to that address.</p> <p>Malicious code injection attacks allow an attacker to seize control of the program. At the conclusion of the attack, the program is still running, but now it is executing code chosen by the attacker, rather than the original code.</p> <p>For instance, consider a web server that receives requests from clients across the network and processes them. If the web server contains a buffer overrun in the code that processes such requests, a malicious client would be able to seize control of the web server process. If the web server is running as root, once the attacker seizes control, the attacker can do anything that root can do; for instance, the attacker can leave a backdoor that allows them to log in as root later. At that point, the system has been “<em>owned</em>”<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p> <p>The attacks illustrated above are only possible when the code satisfies certain special conditions: the buffer that can be overflowed must be followed in memory by some security-critical data (e.g., a function pointer, or a flag that has a critical influence on the subsequent flow of execution of the program). Because these conditions occur only rarely in practice, attackers have developed more effective methods of malicious code injection.</p> <h2 id="32-stack-smashing"> <a href="#32-stack-smashing" class="anchor-heading" aria-labelledby="32-stack-smashing"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.2. Stack smashing </h2> <p>One powerful method for exploiting buffer overrun vulnerabilities takes advantage of the way local variables are laid out on the stack.</p> <p><em>Stack smashing</em> attacks exploit the x86 function call convention. See <a href="https://textbook.cs161.org/memory-safety/x86.html">Chapter 2</a> for a refresher on how x86 function calls work.</p> <p>Suppose the code looks like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void vulnerable() {
    char buf[8];
    gets(buf);
}
</code></pre></div></div> <p>When <code class="language-plaintext highlighter-rouge">vulnerable()</code> is called, a stack frame is pushed onto the stack. The stack will look something like this:</p> <p><img src="/assets/images/memory-safety/vulnerabilities/overflow4.png" alt="Two words of memory for buf overwritten and the rip and sfp above it overwritten" /></p> <p>If the input is too long, the code will write past the end of <code class="language-plaintext highlighter-rouge">buf</code>, overwrite the sfp, and overwrite the rip. This is a <em>stack smashing</em> attack.</p> <p>Note that even though we are on the stack, which “grows down,” our input writes from lower addresses to higher addresses. The stack only grows down when we call a new function and need to allocate additional memory. When we call <code class="language-plaintext highlighter-rouge">gets</code>, user input is still written from lower addresses to higher addresses, just like before.</p> <p>Stack smashing can be used for malicious code injection. First, the attacker arranges to inject a malicious code sequence somewhere in the program’s address space, at a known address (perhaps using techniques previously mentioned). Let’s suppose some malicious code exists at address <code class="language-plaintext highlighter-rouge">0xDEADBEEF</code>.</p> <p>Next, the attacker provides a carefully-chosen input: <code class="language-plaintext highlighter-rouge">AAAAAAAAAAAA\xef\xbe\xad\xde</code>.</p> <p>The first part of this input is a garbage byte <code class="language-plaintext highlighter-rouge">A</code> repeated many times. Since the <code class="language-plaintext highlighter-rouge">gets</code> call writes our user input starting at <code class="language-plaintext highlighter-rouge">buf</code>, we first need to overwrite all 8 bytes of <code class="language-plaintext highlighter-rouge">buf</code> with garbage. Furthermore, we don’t care about the value in the sfp, so we need to overwrite the 4 bytes of the sfp with garbage. In total, we need 8 + 4 = 12 garbage bytes at the beginning of our input.</p> <p>After writing 12 garbage bytes, our next input bytes will overwrite the rip. Recall that the rip contains the address of the next instruction that will be executed after this function returns. If we overwrite the rip with some other address, then when the function returns, it will start executing instructions at that address! This is very similar to the example in the previous section, where we overwrote the function pointer with the address of malicious code.</p> <p>Since malicious code exists at address <code class="language-plaintext highlighter-rouge">0xDEADBEEF</code>, the second part of our input, which overwrites the rip, is the address <code class="language-plaintext highlighter-rouge">0xDEADBEEF</code>. Note that since x86 is little-endian, we must input the bytes in reverse order: the byte <code class="language-plaintext highlighter-rouge">0xEF</code> is entered first, and the byte <code class="language-plaintext highlighter-rouge">0xDE</code> is entered last.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/overflow5.png" alt="Two words of memory for buf and the sfp overwritten with 0xAAAA and the rip overwritten with 0xDEADBEEF" /></p> <p>Now, when the <code class="language-plaintext highlighter-rouge">vulnerable()</code> function returns, the program will start executing instructions at the address in rip. Since we overwrote the rip with the address <code class="language-plaintext highlighter-rouge">0xDEADBEEF</code>, the program will start executing the malicious instructions at that address. This effectively transfers control of the program over to the attacker’s malicious code.</p> <p>Suppose the malicious code didn’t already exist in memory, and we have to inject it ourselves during the stack smashing attack. Sometimes we call this malicious code <em>shellcode</em>, because the malicious code is often written to spawn an interactive shell that lets the attacker perform arbitrary actions.</p> <p>Now suppose the shellcode we want to inject is 8 bytes long. How might we place these bytes in memory? Our new input might look like this:</p> <p><code class="language-plaintext highlighter-rouge">[shellcode] + [4 bytes of garbage] + [address of buf]</code></p> <p>The first part of the input places our 8-byte shellcode at the start of the buffer.</p> <p>At this point, we’ve entered 8 bytes, so we’ve filled up all of <code class="language-plaintext highlighter-rouge">buf</code>. Our next input will overwrite the sfp, but we want to overwrite the rip. As before, we will need to write some garbage bytes to overwrite the sfp so that we can overwrite the rip afterwards. We need 4 bytes of garbage to overwrite the sfp.</p> <p>Finally, we overwrite the rip with the address of shellcode, as before. However, this time, the shellcode is located in the buffer, so we overwrite the rip with the address of <code class="language-plaintext highlighter-rouge">buf</code>. When the function returns, it will start executing instructions at <code class="language-plaintext highlighter-rouge">buf</code>, which causes the shellcode to execute.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/overflow6.png" alt="buf overwritten with shellcode, the sfp overwritten with 0xAAAA, and the rip overwritten with the address of buf" /></p> <p>Now suppose our shellcode is 100 bytes long. If we try our input from before, the shellcode won’t fit in the 12 bytes between the buffer and the rip. It turns out we can still craft an input to exploit the program:</p> <p><code class="language-plaintext highlighter-rouge">[12 bytes of garbage] + [address of rip + 4] + [shellcode]</code></p> <p>In this input, we place the shellcode directly above the rip in memory. The rip is 4 bytes long, so the address of the start of shellcode is 4 bytes greater than the address of the rip. When the function returns, it will start executing instructions 4 bytes above the address of the rip, where we’ve placed our shellcode.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/overflow7.png" alt="Two words of buf and the sfp overwritten with 0xAAAA, the rip overwritten with the address of rip + 4, and the shellcode overwritten above it" /></p> <p>The discussion above has barely scratched the surface of techniques for exploiting buffer overrun bugs. Stack smashing dates back to at least the late 1980s, when the <a href="https://en.wikipedia.org/wiki/Morris_worm">Morris Worm</a> exploited a buffer overflow vulnerability to infect thousands of computers. Buffer overflows gained wider attention in 1998 with the publication of <a href="https://inst.eecs.berkeley.edu/~cs161/fa08/papers/stack_smashing.pdf">“Smashing the Stack for Fun and Profit” by Aleph One</a>.</p> <p>Modern methods are considerably more sophisticated and powerful. These attacks may seem esoteric, but attackers have become highly skilled at exploiting them. Indeed, you can find tutorials on the web explaining how to deal with complications such as:</p> <ul> <li>The malicious code is stored at an unknown location.</li> <li>The buffer is stored on the heap instead of on the stack.</li> <li>The characters that can be written to the buffer are limited (e.g., to only lowercase letters). Imagine writing a malicious sequence of instructions, where every byte in the machine code has to be in the range 0x61 to 0x7A (‘a’ to ‘z’). Yes, it’s been done.</li> <li>There is no way to introduce <em>any</em> malicious code into the program’s address space.</li> </ul> <p>Buffer overrun attacks may appear mysterious or complex or hard to exploit, but in reality, they are none of the above. Attackers exploit these bugs all the time. For example, the <em>Code Red</em> worm compromised 369,000 machines by exploiting a buffer overflow bug in the IIS web server. In the past, many security researchers have underestimated the opportunities for obscure and sophisticated attacks, only to later discover that the ability of attackers to find clever ways to exploit these bugs exceeded their imaginations. Attacks once thought to be esoteric to worry about are now considered easy and routinely mounted by attackers.</p> <p>The bottom line is this: <em>If your program has a buffer overflow bug, you should assume that the bug is exploitable and an attacker can take control of your program.</em></p> <h2 id="33-format-string-vulnerabilities"> <a href="#33-format-string-vulnerabilities" class="anchor-heading" aria-labelledby="33-format-string-vulnerabilities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.3. Format string vulnerabilities </h2> <p>Let’s begin this section by walking through a normal printf call. Suppose we had the following piece of code:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void not_vulnerable() {
    char buf[8];
    if (fgets(buf, sizeof buf, stdin) == NULL)
        return;
    printf(buf);
}
</code></pre></div></div> <p>The stack diagram for this function would look something like this:</p> <p><img src="/assets/images/memory-safety/vulnerabilities/printfnotvulnerable.png" alt="Initial non vulnerable code with printf" /></p> <p>When the <code class="language-plaintext highlighter-rouge">printf()</code> function executes, it looks for a format string modifier denoted by a “%” in its first argument located 4 bytes above the RIP of <code class="language-plaintext highlighter-rouge">printf()</code>. If it finds the modifier, it then looks 8 bytes above the RIP for the “actual” argument (i.e. what the format modifier will be acting upon).</p> <p>The behavior of the <code class="language-plaintext highlighter-rouge">printf()</code> function is generally controlled by the format modifier(s) that are passed into the function. The <code class="language-plaintext highlighter-rouge">printf()</code> function retrieves the parameters that are requested by the format string from the stack. Take, for example, the following line of code: <code class="language-plaintext highlighter-rouge">printf("x has the value %d, y has the value %d, z has the value %d \n", x, y, z);</code> The stack frame for this line of code would look like:</p> <p><img src="/assets/images/memory-safety/vulnerabilities/printfnotvulnerable2.png" alt="Not vulnerable printf statement" /></p> <p>Remember that arguments to a function are pushed onto the stack in reverse order, which is why the address of the format string is at a lower address compared to the values of <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code>.</p> <p><code class="language-plaintext highlighter-rouge">printf()</code>’s internal pointer points to the location on the stack 8 bytes above the RIP of <code class="language-plaintext highlighter-rouge">printf()</code> due to the existence of at least one format string modifier. This internal pointer tells the function where to find the actual arguments that will be modified and eventually printed out.</p> <p>A logical question you might be asking yourself might be, “Well, all this is well and good when everything works fine, but what happens when there is a mismatch in the number of format string modifiers in the first argument and number of additional arguments?” In other words, suppose our printf statement instead looked like this: <code class="language-plaintext highlighter-rouge">printf("x has the value %d, y has the value %d, z has the value %d \n", x, y);</code> Pay close attention to the fact that the format string asks for 3 arguments by having three <code class="language-plaintext highlighter-rouge">%d</code> modifiers, but we only pass in 2 arguments (i.e. <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>).</p> <p>Surely the C compiler is smart enough to catch such a mistake, you might be thinking. Well, unfortunately you would be wrong. <code class="language-plaintext highlighter-rouge">printf()</code> is defined as a function with a variable number of arguments; what this means is that as long as <code class="language-plaintext highlighter-rouge">printf()</code> receives at least one argument, everything looks fine to the compiler! In order to actually spot the mismatch, the compiler would have to understand how the <code class="language-plaintext highlighter-rouge">printf()</code> function actually works and what format string modifiers are – however, compilers aren’t that sophisticated and most of them simply do not perform this kind of analysis.</p> <p>Ok, well, if the C compiler doesn’t catch this type of error, what about the <code class="language-plaintext highlighter-rouge">printf()</code> function itself? <code class="language-plaintext highlighter-rouge">printf()</code> simply fetches arguments from the stack according to the number of format modifiers that are present. In cases of a mismatch, it will fetch some data from the stack that does not belong to the function call.</p> <p>Take the same mismatched <code class="language-plaintext highlighter-rouge">printf()</code> example we had before: <code class="language-plaintext highlighter-rouge">printf("x has the value %d, y has the value %d, z has the value %d \n", x, y);</code> The <code class="language-plaintext highlighter-rouge">printf()</code> function’s internal pointer will start off 8 bytes above the RIP (since it realizes that there is at least one format modifier present). Thus, the <code class="language-plaintext highlighter-rouge">printf()</code> function takes the value 8 bytes above the RIP and prints out whatever is located there; in other words, the first <code class="language-plaintext highlighter-rouge">%d</code> consumes the value located 8 bytes above the RIP of <code class="language-plaintext highlighter-rouge">printf()</code>. Once this happens, the <code class="language-plaintext highlighter-rouge">printf()</code> function locates the next format string modifier (the second <code class="language-plaintext highlighter-rouge">%d</code>), and moves its internal pointer 4 bytes up (so now, the internal pointer is pointing 12 bytes above the RIP of <code class="language-plaintext highlighter-rouge">printf()</code>), before printing out the value located there. Finally, the <code class="language-plaintext highlighter-rouge">printf()</code> function will locate the third format string modifier, and again move its internal pointer 4 bytes up (the internal pointer is now pointing 16 bytes above the RIP of <code class="language-plaintext highlighter-rouge">printf()</code>). However, we never actually passed in a third argument to the <code class="language-plaintext highlighter-rouge">printf()</code> function, so the value located 16 bytes above the RIP of <code class="language-plaintext highlighter-rouge">printf()</code> has nothing to do with the <code class="language-plaintext highlighter-rouge">printf()</code> function at all and is instead some value left over from the previous stack frame. Since the <code class="language-plaintext highlighter-rouge">printf()</code> function does not know this, however, it looks 16 bytes above the RIP of <code class="language-plaintext highlighter-rouge">printf()</code> and prints out the value located there.</p> <p>Similar to how the <code class="language-plaintext highlighter-rouge">%d</code> format modifier simply makes the <code class="language-plaintext highlighter-rouge">printf()</code> function print the value located at the expected address, various format string modifiers have different uses. Here are a couple of examples that might be useful:</p> <ul> <li> <p>%s → Treat the argument as an address and print the string at that address up until the first null byte</p> </li> <li> <p>%n → Treat the argument as an address and write the number of characters that have been printed so far to that address</p> </li> <li> <p>%c → Treat the argument as a value and print it out as a character</p> </li> <li> <p>%x → Look at the stack and read the first variable after the format string</p> </li> <li> <p>%[b]u → Print out [b] bytes starting from the argument</p> </li> </ul> <p>The bottom line: <em>If your program has a format string vulnerability, assume that the attacker can learn any value stored in memory and can take control of your program.</em></p> <h2 id="34-integer-conversion-vulnerabilities"> <a href="#34-integer-conversion-vulnerabilities" class="anchor-heading" aria-labelledby="34-integer-conversion-vulnerabilities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.4. Integer conversion vulnerabilities </h2> <p>What’s wrong with this code?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char buf[8];
void vulnerable() {
    int len = read_int_from_network();
    char *p = read_string_from_network();
    if (len &gt; 8) {
        error("length too large: bad dog, no cookie for you!");
        return;
    }
    memcpy(buf, p, len);
}
</code></pre></div></div> <p>Here’s a hint. The function definition for <code class="language-plaintext highlighter-rouge">memcpy()</code> is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *memcpy(void *dest, const void *src, size_t n);
</code></pre></div></div> <p>And the definition of <code class="language-plaintext highlighter-rouge">size_t</code> is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef unsigned int size_t;
</code></pre></div></div> <p>Do you see the bug now? If the attacker provides a negative value for <code class="language-plaintext highlighter-rouge">len</code>, the <code class="language-plaintext highlighter-rouge">if</code> statement won’t notice anything wrong, and <code class="language-plaintext highlighter-rouge">memcpy()</code> will be executed with a negative third argument. C will cast this negative value to an <code class="language-plaintext highlighter-rouge">unsigned int</code> and it will become a very large positive integer. Thus <code class="language-plaintext highlighter-rouge">memcpy()</code> will copy a huge amount of memory into <code class="language-plaintext highlighter-rouge">buf</code>, overflowing the buffer.</p> <p>Note that the C compiler won’t warn about the type mismatch between <code class="language-plaintext highlighter-rouge">signed int</code> and <code class="language-plaintext highlighter-rouge">unsigned int</code>; it silently inserts an implicit cast. This kind of bug can be hard to spot. The above example is particularly nasty, because on the surface it appears that the programmer has applied the correct bounds checks, but they are flawed.</p> <p>Here is another example. What’s wrong with this code?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void vulnerable() {
    size_t len;
    char *buf;

    len = read_int_from_network();
    buf = malloc(len+5);
    read(fd, buf, len);
    ...
}
</code></pre></div></div> <p>This code seems to avoid buffer overflow problems (indeed, it allocates 5 more bytes than necessary). But, there is a subtle problem: <code class="language-plaintext highlighter-rouge">len+5</code> can wrap around if <code class="language-plaintext highlighter-rouge">len</code> is too large. For instance, if <code class="language-plaintext highlighter-rouge">len = 0xFFFFFFFF</code>, then the value of <code class="language-plaintext highlighter-rouge">len+5</code> is <code class="language-plaintext highlighter-rouge">4</code> (on 32-bit platforms). In this case, the code allocates a 4-byte buffer and then writes a lot more than 4 bytes into it: a classic buffer overflow. You have to know the semantics of your programming language very well to avoid all the pitfalls.</p> <h2 id="35-off-by-one-vulnerabilities"> <a href="#35-off-by-one-vulnerabilities" class="anchor-heading" aria-labelledby="35-off-by-one-vulnerabilities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.5. Off-by-one vulnerabilities </h2> <p>Off-by-one errors are very common in programming: for example, you might accidentally use <code class="language-plaintext highlighter-rouge">&lt;=</code> instead of <code class="language-plaintext highlighter-rouge">&lt;</code>, or you might accidentally start a loop at <code class="language-plaintext highlighter-rouge">i=0</code> instead of <code class="language-plaintext highlighter-rouge">i=1</code>. As it turns out, even an off-by-one error can lead to dangerous memory safety vulnerabilities.</p> <p>Consider a buffer whose bounds checks are off by one. This means we can write <code class="language-plaintext highlighter-rouge">n+1</code> bytes into a buffer of size <code class="language-plaintext highlighter-rouge">n</code>, overflowing the byte immediately after the buffer (but no more than that).</p> <p>This following diagram is from Section 10 of <a href="http://www.icir.org/matthias/cs161-sp13/aslr-bypass.pdf">“ASLR Smack &amp; Laugh Reference” by Tilo Müller</a>. It shows how overwriting a single byte lets you start executing instructions at an arbitrary address in memory.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/offbyone1.png" alt="Stack diagrams showing the exploitation of an off-by-one vulnerability for the first return" /></p> <p><strong>Step 1</strong>: This is what normal execution during a function looks like. Consider reviewing the x86 section of the notes if you’d like a refresher. The stack has the rip (saved eip), sfp (saved ebp), and the local variable <code class="language-plaintext highlighter-rouge">buff</code>. The esp register points to the bottom of the stack. The ebp register points to the sfp at the top of the stack. The sfp (saved ebp) points to the ebp of the previous function, which is higher up in memory. The rip (saved eip) points to somewhere in the code section.</p> <p><strong>Step 2</strong>: We overwrite all of <code class="language-plaintext highlighter-rouge">buff</code>, plus the byte immediately after <code class="language-plaintext highlighter-rouge">buff</code>, which is the least significant byte of the sfp directly above <code class="language-plaintext highlighter-rouge">buff</code>. (Remember that x86 is little-endian, so the least significant byte is stored at the lowest address in memory. For example, if the sfp is <code class="language-plaintext highlighter-rouge">0x12345678</code>, we’d be overwriting the byte <code class="language-plaintext highlighter-rouge">0x78</code>.) We can change the last byte of sfp so that the sfp points to somewhere inside <code class="language-plaintext highlighter-rouge">buff</code>. The SFP label becomes FSP here to indicate that it is now a forged sfp with the last byte changed.</p> <p>Eventually, after your function finishes executing, it returns. Recall from the x86 section of these notes that when a function returns, it executes the following 3 instructions:</p> <p><code class="language-plaintext highlighter-rouge">mov %ebp, %esp</code>: Change the esp register to point to wherever ebp is currently pointing.</p> <p><code class="language-plaintext highlighter-rouge">pop %ebp</code>: Take the next value on the stack (where esp is currently pointing, since esp always points to the bottom of the stack), and place it in the ebp register. Move esp up by 4 to delete this value off the stack.</p> <p><code class="language-plaintext highlighter-rouge">pop %eip</code>: Take the next value on the stack and place it in the eip register. Move esp up by 4 to "delete" this value off the stack.</p> <p>In normal execution, <code class="language-plaintext highlighter-rouge">mov %ebp, %esp</code> causes esp to point to sfp (recall that ebp always points to sfp during function execution). <code class="language-plaintext highlighter-rouge">pop %ebp</code> places the next value on the stack (sfp) inside the ebp register (in other words, you’re restoring the saved ebp back into ebp). <code class="language-plaintext highlighter-rouge">pop %eip</code> places the next value on the stack (rip, just above sfp) inside the eip register (in other words, you’re restoring the saved eip back into eip).</p> <p>So now let’s see what happens if you execute these same 3 instructions when sfp incorrectly points in the buffer.</p> <p><strong>Step 3</strong>: <code class="language-plaintext highlighter-rouge">mov %ebp, %esp</code>: esp now points where ebp is pointing, which is the forged sfp.</p> <p><strong>Step 4</strong>: <code class="language-plaintext highlighter-rouge">pop %ebp</code>: Take the next value on the stack, the forged sfp, and place it in the ebp register. Now ebp is pointing inside the buffer.</p> <p><strong>Step 5</strong>: <code class="language-plaintext highlighter-rouge">pop %eip</code>: Take the next value on the stack, the rip, and place it in the eip register. Since we didn’t maliciously change the rip, the old eip is correctly restored.</p> <p>After step 5, nothing has changed, except that the ebp now points inside the buffer. This makes sense: we only changed the sfp (saved ebp), so when ebp is restored, it will point to where the forged sfp was pointing (inside the buffer).</p> <p>The key insight for this exploit is that one function return is not enough. However, eventually, if a second function return happens, it will allow us to start executing instructions at an arbitrary location. Let’s walk through the same 3 instructions again, but this time with ebp incorrectly pointing in the buffer.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/offbyone2.png" alt="Stack diagrams showing the exploitation of an off-by-one vulnerability for the second return" /></p> <p><strong>Step 6</strong>: <code class="language-plaintext highlighter-rouge">mov %ebp, %esp</code>: esp now points where ebp is pointing, which is inside the buffer. At this point in normal execution, both ebp and esp think that they are pointing at the sfp.</p> <p><strong>Step 7</strong>: <code class="language-plaintext highlighter-rouge">pop %ebp</code>: Take the next value on the stack (which the program thinks is the sfp, but is actually some attacker-controlled value inside the buffer), and place it in the ebp register. The question mark here says that even though the attacker controls what gets placed in the ebp register, we don’t care what the value actually is.</p> <p><strong>Step 8</strong>: <code class="language-plaintext highlighter-rouge">pop %eip</code>: Take the next value on the stack (which the program thinks is the rip, but is actually some attacker-controlled value inside the buffer), and place it in the eip register. This is where you place the address of shellcode, since you control the values in <code class="language-plaintext highlighter-rouge">buff</code>, and the program is taking an address from <code class="language-plaintext highlighter-rouge">buff</code> and jumping there to execute instructions.</p> <p>In step 8, note that there is an offset of 4 from where the forged sfp points and where you should place the address of shellcode. This is because the forged sfp points to a place the program eventually tries to interpret as the sfp, but we care about the place that the program eventually tries to interpret as the rip (which is 4 bytes higher).</p> <p>Also, note that it is not enough to place the shellcode 4 bytes above where the forged sfp is pointing. You need to put the address of shellcode there, since the program will interpret that part of memory as the rip.</p> <h2 id="36-other-memory-safety-vulnerabilities"> <a href="#36-other-memory-safety-vulnerabilities" class="anchor-heading" aria-labelledby="36-other-memory-safety-vulnerabilities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.6. Other memory safety vulnerabilities </h2> <p>Buffer overflows, format string vulnerabilities, and the other examples above are examples of <em>memory safety</em> bugs: cases where an attacker can read or write beyond the valid range of memory regions. Other examples of memory safety violations include using a dangling pointer (a pointer into a memory region that has been freed and is no longer valid) and double-free bugs (where a dynamically allocated object is explicitly freed multiple times).</p> <p>“Use after free” bugs, where an object or structure in memory is deallocated (freed) but still used, are particularly attractive targets for exploitation. Exploiting these vulnerabilities generally involve the attacker triggering the creation of two separate objects that, because of the use-after-free on the first object, actually share the same memory. The attacker can now use the second object to manipulate the interpretation of the first object.</p> <p>C++ vtable pointers are a classic example of a <em>heap overflow</em>. In C++, the programmer can declare an object on the heap. Storing an object requires storing a <em>vtable pointer</em>, a pointer to an array of pointers. Each pointer in the array contains the address of one of that object’s methods. The object’s instance variables are stored directly above the vtable pointer.</p> <p><img src="/assets/images/memory-safety/vulnerabilities/vtable.png" alt="A diagram of a C++ object allocated in the heap, with its instance variables above its vtable" /></p> <p>If the programmer fails to check bounds correctly, the attacker can overflow one of the instance variables of object <code class="language-plaintext highlighter-rouge">x</code>. If there is another object above <code class="language-plaintext highlighter-rouge">x</code> in memory, like object <code class="language-plaintext highlighter-rouge">y</code> in this diagram, then the attacker can overwrite that object’s vtable pointer.</p> <p>The attacker can overwrite the vtable pointer with the address of another attacker-controlled buffer somewhere in memory. In this buffer, the attacker can write the address of some malicious code. Now, when the program calls a method on object <code class="language-plaintext highlighter-rouge">y</code>, it will try to look up the address of the method’s code in <code class="language-plaintext highlighter-rouge">y</code>’s vtable. However, <code class="language-plaintext highlighter-rouge">y</code>’s vtable pointer has been overwritten to point to attacker-controlled memory, and the attacker has written the address of some malicious code at that memory. This causes the program to start executing the attacker’s malicious code.</p> <p>This method of injection is very similar to stack smashing, where the attacker overwrites the rip to point to some malicious code. However, overwriting C++ vtables requires overwriting a pointer to a pointer.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>You sometimes see variants on this like pwned, 0wned, ownzored, etc. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
