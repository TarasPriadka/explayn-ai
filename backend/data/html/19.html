<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>16. Bitcoin - Computer Security</title> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Bitcoin | Computer Security</title> <meta name="generator" content="Jekyll v3.9.2" /> <meta property="og:title" content="Bitcoin" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <meta property="og:description" content="Online textbook for CS 161: Computer Security at UC Berkeley." /> <link rel="canonical" href="/crypto/bitcoin.html" /> <meta property="og:url" content="/crypto/bitcoin.html" /> <meta property="og:site_name" content="Computer Security" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Bitcoin" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Online textbook for CS 161: Computer Security at UC Berkeley.","headline":"Bitcoin","url":"/crypto/bitcoin.html"}</script> <!-- End Jekyll SEO tag --> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" ></script> <script> let toggleDark = () => { let setDark = jtd.getTheme() !== 'dark'; jtd.setTheme(setDark ? 'dark' : 'default'); localStorage.setItem('darkMode', String(setDark)); }; window.addEventListener('DOMContentLoaded', () => { /* Add event to dark mode button. */ let a = document.getElementsByClassName('site-button')[2]; a.addEventListener('click', (e) => { e.preventDefault(); toggleDark(); }); /* Read local storage state. */ if (localStorage.getItem('darkMode') === 'true') { toggleDark(); } }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/" class="site-title lh-tight"> Computer Security </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Introduction</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Security Principles category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/principles/" class="nav-list-link">Security Principles</a><ul class="nav-list "><li class="nav-list-item "><a href="/principles/principles.html" class="nav-list-link">1. Security Principles</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Memory Safety category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/memory-safety/" class="nav-list-link">Memory Safety</a><ul class="nav-list "><li class="nav-list-item "><a href="/memory-safety/x86.html" class="nav-list-link">2. x86 Assembly and Call Stack</a></li><li class="nav-list-item "><a href="/memory-safety/vulnerabilities.html" class="nav-list-link">3. Memory Safety Vulnerabilities</a></li><li class="nav-list-item "><a href="/memory-safety/mitigations.html" class="nav-list-link">4. Mitigating Memory-Safety Vulnerabilities</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Cryptography category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/crypto/" class="nav-list-link">Cryptography</a><ul class="nav-list "><li class="nav-list-item "><a href="/crypto/intro.html" class="nav-list-link">5. Introduction to Cryptography</a></li><li class="nav-list-item "><a href="/crypto/symmetric.html" class="nav-list-link">6. Symmetric-Key Cryptography</a></li><li class="nav-list-item "><a href="/crypto/hashes.html" class="nav-list-link">7. Cryptographic Hashes</a></li><li class="nav-list-item "><a href="/crypto/macs.html" class="nav-list-link">8. Message Authentication Codes (MACs)</a></li><li class="nav-list-item "><a href="/crypto/prng.html" class="nav-list-link">9. Pseudorandom Number Generators</a></li><li class="nav-list-item "><a href="/crypto/key-exchange.html" class="nav-list-link">10. Diffie-Hellman Key Exchange</a></li><li class="nav-list-item "><a href="/crypto/public-key.html" class="nav-list-link">11. Public-Key Encryption</a></li><li class="nav-list-item "><a href="/crypto/signatures.html" class="nav-list-link">12. Digital Signatures</a></li><li class="nav-list-item "><a href="/crypto/certificates.html" class="nav-list-link">13. Certificates</a></li><li class="nav-list-item "><a href="/crypto/passwords.html" class="nav-list-link">14. Passwords</a></li><li class="nav-list-item "><a href="/crypto/case-studies.html" class="nav-list-link">15. Case Studies</a></li><li class="nav-list-item active"><a href="/crypto/bitcoin.html" class="nav-list-link active">16. Bitcoin</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Web Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/web/" class="nav-list-link">Web Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/web/sqli.html" class="nav-list-link">17. SQL Injection</a></li><li class="nav-list-item "><a href="/web/intro.html" class="nav-list-link">18. Introduction to the Web</a></li><li class="nav-list-item "><a href="/web/sop.html" class="nav-list-link">19. Same-Origin Policy</a></li><li class="nav-list-item "><a href="/web/cookies.html" class="nav-list-link">20. Cookies and Session Management</a></li><li class="nav-list-item "><a href="/web/csrf.html" class="nav-list-link">21. Cross-Site Request Forgery (CSRF)</a></li><li class="nav-list-item "><a href="/web/xss.html" class="nav-list-link">22. Cross-Site Scripting (XSS)</a></li><li class="nav-list-item "><a href="/web/ui-attacks.html" class="nav-list-link">23. UI Attacks</a></li><li class="nav-list-item "><a href="/web/captchas.html" class="nav-list-link">24. CAPTCHAs</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Network Security category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/network/" class="nav-list-link">Network Security</a><ul class="nav-list "><li class="nav-list-item "><a href="/network/intro.html" class="nav-list-link">25. Introduction to Networking</a></li><li class="nav-list-item "><a href="/network/arp.html" class="nav-list-link">26. ARP</a></li><li class="nav-list-item "><a href="/network/wpa.html" class="nav-list-link">27. WPA</a></li><li class="nav-list-item "><a href="/network/dhcp.html" class="nav-list-link">28. DHCP</a></li><li class="nav-list-item "><a href="/network/bgp.html" class="nav-list-link">29. BGP</a></li><li class="nav-list-item "><a href="/network/transport.html" class="nav-list-link">30. TCP and UDP</a></li><li class="nav-list-item "><a href="/network/tls.html" class="nav-list-link">31. TLS</a></li><li class="nav-list-item "><a href="/network/dns.html" class="nav-list-link">32. DNS</a></li><li class="nav-list-item "><a href="/network/dnssec.html" class="nav-list-link">33. DNSSEC</a></li><li class="nav-list-item "><a href="/network/dos.html" class="nav-list-link">34. Denial-of-Service (DoS)</a></li><li class="nav-list-item "><a href="/network/firewalls.html" class="nav-list-link">35. Firewalls</a></li><li class="nav-list-item "><a href="/network/intrusion-detection.html" class="nav-list-link">36. Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/abusing-intrusion-detection.html" class="nav-list-link">37. Abusing Intrusion Detection</a></li><li class="nav-list-item "><a href="/network/malware.html" class="nav-list-link">38. Malware</a></li><li class="nav-list-item "><a href="/network/tor.html" class="nav-list-link">39. Anonymity and Tor</a></li></ul></li><li class="nav-list-item"><a href="/glossary.html" class="nav-list-link">Glossary</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Computer Security" aria-label="Search Computer Security" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://cs161.org" class="site-button" > CS 161 </a> </li> <li class="aux-nav-list-item"> <a href="#" class="site-button" > Dark Mode </a> </li> </ul> </nav> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/crypto/">Cryptography</a></li> <li class="breadcrumb-nav-list-item"><span>16. Bitcoin</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 id="16-bitcoin"> <a href="#16-bitcoin" class="anchor-heading" aria-labelledby="16-bitcoin"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16. Bitcoin </h1> <h2 id="161-problem-statement"> <a href="#161-problem-statement" class="anchor-heading" aria-labelledby="161-problem-statement"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.1. Problem Statement </h2> <p>Bitcoin is a digital cryptocurrency, which means it should have all the same properties as physical currency (e.g. the United States dollar). In our simplified model, a functioning currency should have the following properties:</p> <ul> <li> <p>Each person has a bank account, in which they can store units of currency they own.</p> </li> <li> <p>Alice cannot impersonate Bob and perform actions as Bob.</p> </li> <li> <p>Any two people can engage in a <em>transaction</em>. Alice can send Bob \(n\) units of currency. This will cause Alice’s bank account balance to decrease by \(n\) units, and Bob’s bank account to increase by \(n\) units.</p> </li> <li> <p>If Alice has \(n\) units of currency in her account, she cannot spend any more than \(n\) units in any transaction.</p> </li> </ul> <p>In traditional physical currency, these properties are enforced by a trusted, centralized party such as a bank. Everyone trusts the bank to keep an accurate list of account holders with their appropriate account balances, and ensure that the identity of each user is correct before proceeding with a transaction. So, if Alice sends \(n\) units to Bob, both Alice and Bob trust that the bank will correctly decrease Alice’s balance by \(n\) and increase Bob’s balance by \(n\). Everyone also trusts that the bank will not let Alice spend \(n+1\) units of currency if she only has \(n\) units in her account.</p> <p>The goal of Bitcoin is to replicate these basic properties of a functioning currency system, but without any centralized party. Instead of relying on a trusted entity, Bitcoin uses cryptography to enforce the basic properties of currency.</p> <h2 id="162-cryptographic-primitives"> <a href="#162-cryptographic-primitives" class="anchor-heading" aria-labelledby="162-cryptographic-primitives"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.2. Cryptographic Primitives </h2> <p>Bitcoin uses two cryptographic primitives that you have already seen in this class. Let’s briefly review their definitions and relevant properties.</p> <p>A <em>cryptographic hash</em> is a function \(H\) that maps arbitrary-length input \(x\) to a fixed-length output \(H(x)\). The hash is collision-resistant, which means it is infeasible to find two different inputs that map to the same output. In math, it is infeasible to find \(x \neq y\) such that \(H(x) = H(y)\).</p> <p>A <em>digital signature</em> is a cryptographic scheme that guarantees authenticity on a message. Alice generates a public verification key \(PK\) and a secret signing key \(SK\). She broadcasts the public key to the world and keeps the secret key to herself. When Alice writes a message, she uses the secret key to generate a signature on her message and attaches the signature to the message. Anyone else can now use the public key to verify that the signature is valid, proving that the message was written by Alice and nobody tampered with it.</p> <p>With these two cryptographic primitives in mind, we can now start designing Bitcoin.</p> <h2 id="163-identities"> <a href="#163-identities" class="anchor-heading" aria-labelledby="163-identities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.3. Identities </h2> <p>Since there is no centralized party to keep track of everyone’s accounts, we will need to assign a unique identity to everyone. We also need to prevent malicious users from pretending to be other users.</p> <p>Every user of Bitcoin generates a public key and private key. Their identity is the public key. For example, Bob generates \(PK_B\) and \(SK_B\) and publishes \(PK_B\) to the world, so now his identity in Bitcoin is \(PK_B\). When Bob is interacting with Bitcoin, he can prove that he is the user corresponding to \(PK_B\) by creating a message and signing it with \(SK_B\). Then anybody can use \(PK_B\) to verify his signature and confirm that he is indeed the \(PK_B\) user. Because digital signatures are unforgeable, an attacker who doesn’t know Bob’s secret signing key will be unable to impersonate Bob, because the attacker cannot generate a signature that validates with \(PK_B\).</p> <h2 id="164-transactions"> <a href="#164-transactions" class="anchor-heading" aria-labelledby="164-transactions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.4. Transactions </h2> <p>Without a centralized party to validate transactions, we will need a way to cryptographically verify that Alice actually wants to send \(n\) units of currency to Bob. Fortunately, this problem is essentially solved with our identity scheme above. If Alice wants to send \(n\) units of currency to Bob, she can create a message “\(PK_A\) sends \(n\) units of currency to \(PK_B\)” and sign it with her secret key. Note how she uses her public key \(PK_A\) as her identity and Bob’s public key \(PK_B\) as his identity. Now anybody can verify the signature with Alice’s public key to confirm that the user \(PK_A\) did intend to make this transaction. Bitcoin doesn’t validate the recipient–if someone wanted to refuse a transaction, they could create another transaction to send the money back.</p> <h2 id="165-balances"> <a href="#165-balances" class="anchor-heading" aria-labelledby="165-balances"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.5. Balances </h2> <p>In our transaction scheme so far, nothing is stopping Alice from creating and signing a message “\(PK_A\) sends \(100n\) units of currency to \(PK_B\),” even though she may only have \(n\) units of currency to spend. We need some way to keep track of each user’s balances.</p> <p>For now, assume that there is a <em>trusted ledger</em>. A ledger is a written record that everybody can view. It is append-only and immutable, which means you can only add new entries to the ledger, and you cannot change existing entries in the ledger. You can think of the ledger like a guest book: when you visit, you can add your own entry, and you can view existing entries, but you cannot (or should not) change other people’s old entries. Later we will see how to build a decentralized ledger using cryptography.</p> <p>Bitcoin does not explicitly record the balance of every user. Instead, every completed transaction (along with its signature) is recorded in the public ledger. Since everyone can view the ledger, anybody can identify an invalid transaction, such as Alice trying to spend more than she has. For example, suppose Bob starts with $10 and everyone else starts with $0. (We will discuss where Bob got the $10 later.) Consider the following ledger:</p> <ul> <li> <p>\(PK_B\) (Bob) sends \(PK_A\) (Alice) $5. Message signed with \(SK_B\).</p> </li> <li> <p>\(PK_B\) (Bob) sends \(PK_M\) (Mallory) $2. Message signed with \(SK_B\).</p> </li> <li> <p>\(PK_M\) (Mallory) sends \(PK_A\) (Alice) $1. Message signed with \(SK_M\).</p> </li> <li> <p>\(PK_A\) (Alice) sends \(PK_E\) (Eve) $9. Message signed with \(SK_A\).</p> </li> </ul> <p>Can you spot the invalid transaction? Although we don’t have the balances of each user, the transaction ledger gives us enough information to deduce every user’s balance at any given time. In this example, after the first three transactions, Bob has $3, Mallory has $1, and Alice has $6. In the fourth transaction, Alice is trying to spend $9 when she only has $6, so we know it must be an invalid transaction. Because the ledger is trusted, it will reject this invalid transaction.</p> <p>Thus, the idea is to have each block have a list of the transactions that show where the money being used in this transaction came from, which also means that blocks have to be sorted in order of creation. Now, our ledger looks as follows (again assuming that Bob starts with 10\(B\) and everyone else starts with 0\(B\):</p> <ul> <li>\(TX_1\) = \(PK_B\) (Bob) sends \(PK_A\) (Alice) 5\(B\), and the money came from the initial budget. \(TX_1\) signed with \(SK_B\)</li> <li>\(TX_2\) = \(PK_A\) (Alice) sends \(PK_E\) (Eve) 5\(B\), and the money came from \(TX_1\). \(TX_2\) signed with \(SK_A\)</li> </ul> <p>So, to check a transaction, we follow three steps:</p> <ol> <li>Check that the signature on the transaction is verified using the \(PK\) of the sender</li> <li>Check that the sender in this transaction was the receiver in some previous transaction</li> <li>Check that the sender in this transaction has not spent the money in some previous transaction (aka they have enough money left over)</li> </ol> <p>If we were checking \(TX_2\), we first check that \(TX_2\) was actually signed by Alice. Then, we check that Alice received some money in the past by checking the previous transactions. In \(TX_2\), we see that Alice received the money from \(TX_1\), and checking \(TX_1\) verifies that Alice was the receiver. Next, we check that Alice has not spent the money earlier, so we scan the history of the blockchain and we don’t see anywhere where the money from \(TX_1\) was used. Finally, we check that Alice has 5 \(B\) by again checking \(TX_1\) and seeing that she did receive 5 \(B\) from Bob. At this point, we have verified that \(TX_2\) is a valid transaction, and we thus append it to the blockchain ledger.</p> <p>At this point, we have created a functioning currency:</p> <ul> <li> <p>Each person has a unique account, uniquely identified by public key.</p> </li> <li> <p>Users cannot impersonate other users, because each user can be validated by a secret signing key that only that user knows.</p> </li> <li> <p>Users can engage in a transaction by having the sender add their transaction to the ledger, with a signature on the transaction.</p> </li> <li> <p>Users cannot spend more than their current balance, because the trusted ledger is append-only, and everyone is able to calculate balances from the ledger.</p> </li> </ul> <p>The only remaining design element is creating a decentralized append-only ledger, which we will discuss next.</p> <h2 id="166-hash-chains"> <a href="#166-hash-chains" class="anchor-heading" aria-labelledby="166-hash-chains"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.6. Hash chains </h2> <p>Recall that we need a public ledger that is append-only and immutable: everyone can add entries to the ledger, but nobody can modify or delete existing entries.</p> <p>To build this ledger, we will start with a <em>hash chain</em>. Suppose we have five messages, \(m_1, m_2, \ldots, m_5\) that we want to append to the ledger. The resulting hash chain would look like this:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Block 1</th> <th>Block 2</th> <th>Block 3</th> <th>Block 4</th> <th>Block 5</th> </tr> </thead> <tbody> <tr> <td>\(m_1\)</td> <td>\(m_2, H(\text{Block 1})\)</td> <td>\(m_3, H(\text{Block 2})\)</td> <td>\(m_4, H(\text{Block 3})\)</td> <td>\(m_5, H(\text{Block 4})\)</td> </tr> </tbody> </table></div> <p>Note that each block contains the hash of the previous block, which in turn contains the hash of the previous block, etc. In other words, each time we append a new message in a new block, the hash of the previous block contains a digest of all the entries in the hash chain so far.</p> <p>Another way to see this is to write out the hashes. For example:</p> <p>\(\text{Block 4} = m_4, H(\text{Block 3})\)<br />     \(= m_4, H(m_3, H(\text{Block 2}))\)<br />     \(= m_4, H(m_3, H(m_2, H(\text{Block 1})))\)<br />     \(= m_4, H(m_3, H(m_2, H(m_1)))\)</p> <p>Note that Block 4 contains a digest of all the messages so far, namely \(m_1, m_2, m_3, m_4\).</p> <h2 id="167-properties-of-hash-chains"> <a href="#167-properties-of-hash-chains" class="anchor-heading" aria-labelledby="167-properties-of-hash-chains"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.7. Properties of Hash Chains </h2> <p>Assume that Alice is given the \(H(\text{Block } i)\) from a trusted source, but she downloads blocks 1 through \(i\) from an untrusted source. Only using the \(H(\text{Block } i)\), Alice can verify that the blocks she downloaded from the untrusted source are not compromised by recomputing the hashes of each block, checking that they match the hash in the next block, and so on, until the last block, which she checks against the hash she received from the trusted source. Let’s walk through an example:</p> <p>Say Alice received the \(H(\text{Block 4})\) from somewhere she trusts and then fetches the entire blockchain from a compromised server (so she downloads blocks 1 through 4). Can an attacker give Alice an incorrect chain, say with block 2 being incorrect, without her detecting it? No! Since we use cryptographic hashes, which are collision resistant, two different blocks cannot hash to the same value. Say that block 2 is incorrect and Alice instead received block \(2'\), then \(H(\text{Block } 2')\) \(\neq\) \(H(\text{Block 2})\). Since block 3 includes the hash of block \(2'\), block 3 will also be incorrect, so the third block that Alice received is block \(3'\) \(\neq\) block 3. So, \(H(\text{Block } 3')\) \(\neq\) \(H(\text{Block 3})\). Then, since block 4 includes the hash of block \(3'\), block 4 will also be incorrect, so the fourth block that Alice received is block \(4'\) \(\neq\) block 4. So, \(H(\text{Block } 4')\) \(\neq\) \(H(\text{Block 4})\). Since Alice received H(block 4) from a trusted source, and it does not match up with \(H(\text{Block} 4')\), Alice is able to detect misbehavior. On the other hand, if the \(H(\text{Block } 4')\) did match \(H(\text{Block 4})\), then the blockchain that Alice downloaded is correct, and we have no misbehavior.</p> <p>So, perhaps the most important property in a hash chain is that if you get the hash of the latest block from a trusted source, then you can verify that all of the previous history is correct.</p> <h2 id="168-consensus-in-bitcoin"> <a href="#168-consensus-in-bitcoin" class="anchor-heading" aria-labelledby="168-consensus-in-bitcoin"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.8. Consensus in Bitcoin </h2> <p>In Bitcoin, every participant in the network stores the entire blockchain (and thus all of its history) since we don’t utilize a centralized server. When someone wants to create a new transaction, they broadcast that transaction to everyone, and each user on the network has to check the transaction. If the transaction is correct, they will append it to their local blockchain.</p> <p>The issue is that some users might be malicious, meaning that they might not append certain transactions or might not check certain transactions correctly or might replay certain transactions or might allow invalid transactions. Bitcoin, however, assumes that the majority of users are honest.</p> <p>Perhaps one of the biggest issues is forks, which are essentially different versions of the blockchain that exist at the same time. For example, say that Mallory bought a house from Bob for 500 \(B\), and this transaction is appended to the ledger. Mallory can then try “go back in time” and start the blockchain from just before this transaction was added to it, and can start appending new transaction entries from there. If Mallory can get other users to accept this new forked chain, she can get her 500 \(B\) back!</p> <p>This means that we need a way for all users to agree on the content of the blockchain: <em>consensus via proof of work</em>.</p> <h2 id="169-consensus-via-proof-of-work"> <a href="#169-consensus-via-proof-of-work" class="anchor-heading" aria-labelledby="169-consensus-via-proof-of-work"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 16.9. Consensus via Proof of Work </h2> <p>In Bitcoin, while every user locally stores the entire blockchain, not every user can add a block. This special privilege is reserved for certain users, known as <em>miners</em>, who can only add a block if they have a valid proof of work. A miner validates transactions before solving a <em>proof of work</em>, which, if completed before any other miner, allows the miner to append the block to the blockchain. The proof of work is a computational puzzle that takes the hash of the current block concatenated with a random number. This random number can be incremented so that the hash changes, until the proof of work is solved. The proof of work is considered solved when the resulting hash starts with \(N\) zero bits, where the value of \(N\) (e.g. 33) is determined by the Bitcoin algorithm.</p> <p>Miners then broadcast blocks with their proof of work. All honest miners listen for such blocks, check the blocks for correctness, and <em>accept the longest correct chain</em>. If a miner appends a block with some incorrect transaction, the block is ignored. The key idea for consensus is that everyone will always prefer the longest correct chain. Thus, if multiple miners append blocks at the same time, consensus is gained by the longest correct chain, and the rest of the “versions” are discarded. When two different miners at the same time solve a proof of work and append two different blocks, thus forking the network, the next miner that appends onto one of these chains invalidates the other chain.</p> <p>Say for example that an honest miner \(M_1\) stores the current local blockchain \(b_1\)→\(b_2\)→\(b_3\), and hears about transaction \(T\). \(M_1\) checks \(T\), then tries to mine (solve for the proof of work) for a new block \(b_4\) to now include transaction \(T\). However, if miner \(M_2\) mines \(b_4\) first, \(M_2\) will broadcast \(b_1\)→\(b_2\)→\(b_3\)→\(b_4\). \(M_1\) checks \(b_4\), accepts it, gives up mining block 4, then starts to mine for block 5. \(M_1\) now has the blockchain \(b_1\)→\(b_2\)→\(b_3\)→\(b_4\) stored locally and has started to mine \(b_5\). However, if \(M_1\) hears miner 3 broadcasts \(b_1\)→\(b_2\)→\(b_3\)→\(b_4’\)→\(b_5’\), \(M_1\) will discard the shorter blockchain (\(b_1\)→\(b_2\)→\(b_3\)→\(b_4\)) in favor of the longer one (\(b_1\)→\(b_2\)→\(b_3\)→\(b_4’\)→\(b_5’\)). By always accepting the longest blockchain, all the miners are ensured to have the same blockchain view.</p> <p>Remember that Bitcoin assumes that more than half of the users are honest, meaning that more than half of the computing power is in the hands of honest miners, thus ensuring that honest miners will always have an advantage to mine the longest chain. Going back to the example about forks that prompted this discussion, if proof of consensus is implemented, Mallory cannot fork the blockchain since she does not have &gt;50% of the computing power in the world. Since the longest chain is always taken as the accepted, Mallory’s forked chain will be shorter unless she can mine new entries faster than the aggregate mining power of everyone else in the world.</p> <p>Go forth and mine!</p> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
